<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>不/存在的你，和我 - 莉莉丝 PV</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700;900&family=Noto+Sans+JP:wght@400;700&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0a0a; overflow: hidden; font-family: 'Noto Serif SC', 'Noto Sans JP', serif; color: #fff; }
        #container { width: 100vw; height: 100vh; position: relative; overflow: hidden; }
        
        .bg-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .noise { z-index: 1000; opacity: 0.025; background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%' height='100%' filter='url(%23noise)'/%3E%3C/svg%3E"); }
        .scanlines { z-index: 999; background: repeating-linear-gradient(0deg, rgba(0,0,0,0.15) 0px, rgba(0,0,0,0.15) 1px, transparent 1px, transparent 3px); }
        .vignette { z-index: 998; background: radial-gradient(ellipse at center, transparent 30%, rgba(0,0,0,0.85) 100%); }
        
        .transition-system { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2000; pointer-events: none; }
        .mask-strip { position: absolute; background: #c41e3a; }
        
        .scene-container { position: absolute; width: 100%; height: 100%; top: 0; left: 0; z-index: 100; transition: opacity 1.5s ease, filter 1.5s ease, visibility 0s 1.5s; }
        .scene-container.fade-out { opacity: 0; filter: blur(10px); visibility: hidden; }
        .main-canvas { position: absolute; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
        
        .pv-image { position: absolute; overflow: hidden; }
        .pv-image img { width: 100%; height: 100%; object-fit: cover; }
        .shadow-red { box-shadow: 12px 12px 0 #c41e3a, 24px 24px 0 #000; }
        .shadow-white { box-shadow: -10px 10px 0 #fff, -20px 20px 0 #000; }
        .shadow-glow { box-shadow: 0 0 60px rgba(196,30,58,0.6), 15px 15px 0 #000; }
        .shadow-deep { box-shadow: 5px 5px 0 #c41e3a, 10px 10px 0 #8b0000, 15px 15px 0 #500, 20px 20px 0 #000; }
        .border-thin { border: 2px solid #fff; }
        .border-thick { border: 6px solid #c41e3a; }
        .border-double { border: 3px solid #fff; outline: 3px solid #c41e3a; outline-offset: 5px; }
        .pv-text { position: absolute; font-weight: 700; letter-spacing: 0.15em; white-space: nowrap; }
        .text-shadow-hard { text-shadow: 4px 4px 0 #8b0000, 8px 8px 0 #000; }
        .text-shadow-glow { text-shadow: 0 0 20px #c41e3a, 0 0 40px rgba(196,30,58,0.5), 4px 4px 0 #000; }
        
        /* 歌词 */
        .lyrics-container { 
            position: fixed; 
            bottom: -200px; /* 初始隐藏在底部 */
            left: 0; 
            width: 100%; 
            text-align: center; 
            z-index: 400; 
            pointer-events: none; 
            transition: bottom 0.3s ease, opacity 1s ease;
        }
        .lyrics-container.hidden { opacity: 0; visibility: hidden; }
        .lyrics-container.visible { bottom: 100px; } /* 显示时的位置 */
        .lyric-line { font-size: 1.8rem; color: #fff; letter-spacing: 0.12em; opacity: 0; margin: 10px 0; text-shadow: 0 0 20px rgba(196,30,58,0.8), 3px 3px 0 #000; }
        .lyric-line.jp { font-size: 1.3rem; color: #c41e3a; }
        .lyric-anim-typewriter .lyric-char { opacity: 0; animation: typeChar 0.05s ease forwards; }
        .lyric-anim-wave .lyric-char { display: inline-block; animation: waveChar 0.6s ease forwards; }
        .lyric-anim-glitch { animation: glitchText 0.5s ease forwards; }
        .lyric-anim-blur { filter: blur(20px); opacity: 0; animation: blurIn 0.8s ease forwards; }
        .lyric-anim-3d { transform: perspective(500px) rotateX(-90deg); animation: rotate3dIn 0.8s cubic-bezier(0.16,1,0.3,1) forwards; }
        .lyric-anim-scatter .lyric-char { display: inline-block; opacity: 0; transform: translate(calc((var(--r1) - 0.5) * 200px), calc((var(--r2) - 0.5) * 200px)) rotate(calc((var(--r1) - 0.5) * 180deg)); animation: scatterIn 0.8s cubic-bezier(0.16,1,0.3,1) forwards; }
        .lyric-exit-blur { animation: blurOut 0.5s ease forwards; }
        
        /* 音频控制 */
        .audio-control { 
            position: fixed; 
            bottom: -80px; /* 初始隐藏在屏幕下方 */
            left: 50%; 
            transform: translateX(-50%); 
            z-index: 1001; 
            display: flex; 
            align-items: center; 
            gap: 20px; 
            background: rgba(0,0,0,0.85); 
            padding: 12px 25px; 
            border: 1px solid rgba(196,30,58,0.5);
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            transition: bottom 0.3s ease;
        }
        .audio-control:hover,
        .audio-control.visible { 
            bottom: 0; 
        }
        /* 触发区域 - 屏幕底部的隐形区域 */
        .audio-trigger {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50px;
            z-index: 1000;
        }
        /* 底部提示小物件 */
        .bottom-hint {
            position: fixed;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: rgba(196,30,58,0.3);
            border-radius: 2px;
            z-index: 999;
            transition: all 0.3s ease;
            animation: hintPulse 2s ease-in-out infinite;
        }
        .audio-trigger:hover ~ .bottom-hint {
            opacity: 0;
        }
        .play-btn { width: 45px; height: 45px; border: 2px solid #c41e3a; background: transparent; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.3s ease; }
        .play-btn:hover { background: #c41e3a; box-shadow: 0 0 25px rgba(196,30,58,0.7); }
        .play-btn svg { fill: #fff; width: 18px; height: 18px; }
        .progress-container { width: 280px; height: 4px; background: rgba(255,255,255,0.15); cursor: pointer; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #c41e3a, #ff4757); width: 0%; }
        .time-display { font-size: 0.85rem; color: #888; font-family: monospace; min-width: 90px; }
        
        /* 加载 */
        .loading-screen { position: fixed; inset: 0; background: #0a0a0a; z-index: 5000; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .loading-screen.hidden { animation: fadeOut 1s ease forwards; pointer-events: none; }
        .loading-text { font-size: 2rem; color: #c41e3a; letter-spacing: 1em; margin-bottom: 40px; }
        .loading-progress { width: 300px; height: 2px; background: rgba(255,255,255,0.1); }
        .loading-progress-fill { height: 100%; background: #c41e3a; width: 0%; transition: width 0.3s ease; }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-text">LOADING</div>
        <div class="loading-progress"><div class="loading-progress-fill" id="loadingFill"></div></div>
    </div>
    
    <div id="container">
        <div class="bg-layer noise"></div>
        <div class="bg-layer scanlines"></div>
        <div class="bg-layer vignette"></div>
        <div class="transition-system" id="transitionSystem"></div>
        <div class="scene-container" id="sceneContainer"></div>
        <div class="pv-lyric-overlay" id="pvLyricOverlay"></div>
        <div class="lyrics-container" id="lyricsContainer">
            <div class="lyric-line" id="lyricCn"></div>
            <div class="lyric-line jp" id="lyricJp"></div>
        </div>
    </div>
    
    <!-- 相册模式 -->
    <div class="album-mode" id="albumMode">
        <!-- 背景动画特效 -->
        <div class="album-bg-effects">
            <!-- 老旧胶片颗粒感 -->
            <div class="album-film-grain"></div>
            
            <!-- 怀旧暖色光晕 -->
            <div class="album-warm-glow album-warm-glow-1"></div>
            <div class="album-warm-glow album-warm-glow-2"></div>
            
            <!-- 飘落的花瓣 -->
            <div class="album-petal"></div>
            <div class="album-petal"></div>
            <div class="album-petal"></div>
            <div class="album-petal"></div>
            <div class="album-petal"></div>
            <div class="album-petal"></div>
            <div class="album-petal"></div>
            <div class="album-petal"></div>
            
            <!-- 漂浮的记忆光点 -->
            <div class="album-memory-light"></div>
            <div class="album-memory-light"></div>
            <div class="album-memory-light"></div>
            <div class="album-memory-light"></div>
            <div class="album-memory-light"></div>
            <div class="album-memory-light"></div>
            
            <!-- 柔和的光线射入 -->
            <div class="album-light-ray"></div>
            
            <!-- 边缘暗角 -->
            <div class="album-vignette"></div>
        </div>
        
        <!-- 书桌装饰元素 - 复古钢笔 -->
        <div class="desk-pen"></div>
        
        <div class="album-book" id="albumBook">
            <!-- 封底（最底层，始终可见的左半部分） -->
            <div class="book-back-cover" id="backCover"></div>
            
            <!-- 最后一页的底层（当所有页翻完后显示） -->
            <div class="book-last-page" id="lastPage"></div>
            
            <!-- 可翻动的页面容器 -->
            <div class="flippable-pages" id="flippablePages"></div>
            
            <!-- 封面（最上层，初始覆盖整个右侧） -->
            <div class="book-cover" id="bookCover">
                <div class="cover-front">
                    <div class="cover-content">
                        <div class="cover-deco top-left"></div>
                        <div class="cover-deco top-right"></div>
                        <div class="cover-deco bottom-left"></div>
                        <div class="cover-deco bottom-right"></div>
                        <div class="cover-title">不/存在的你，和我</div>
                        <div class="cover-subtitle">莉莉丝 · TULPA</div>
                        <div class="cover-line"></div>
                        <div class="cover-hint">点击翻开相册</div>
                    </div>
                </div>
                <div class="cover-back">
                    <div class="toc-content">
                        <div class="toc-deco top-left"></div>
                        <div class="toc-deco top-right"></div>
                        <div class="toc-deco bottom-left"></div>
                        <div class="toc-deco bottom-right"></div>
                        <div class="toc-title">目 录</div>
                        <div class="toc-line"></div>
                        <div class="toc-items">
                            <div class="toc-item">
                                <span class="toc-item-icon">◆</span>
                                <span class="toc-item-text">图 片</span>
                                <span class="toc-item-dots"></span>
                                <span class="toc-item-page">01</span>
                            </div>
                            <div class="toc-item">
                                <span class="toc-item-icon">◆</span>
                                <span class="toc-item-text">视 频</span>
                                <span class="toc-item-dots"></span>
                                <span class="toc-item-page">05</span>
                            </div>
                            <div class="toc-item">
                                <span class="toc-item-icon">◆</span>
                                <span class="toc-item-text">文 字</span>
                                <span class="toc-item-dots"></span>
                                <span class="toc-item-page">07</span>
                            </div>
                        </div>
                        <div class="toc-footer">CONTENTS</div>
                    </div>
                </div>
            </div>
        </div>
        <div class="album-nav" id="albumNav">
            <button class="album-nav-btn" id="prevPage"><span>◀</span> 上一页</button>
            <div class="album-page-indicator" id="pageIndicator">1 / 1</div>
            <button class="album-nav-btn" id="nextPage">下一页 <span>▶</span></button>
        </div>
    </div>
    
    <!-- 图片查看器 -->
    <div class="viewer" id="viewer">
        <div class="viewer-backdrop"></div>
        <button class="viewer-close" id="viewerClose"></button>
        <div class="viewer-content">
            <div class="viewer-photo-frame">
                <div class="viewer-photo-mat"><img class="viewer-image" id="viewerImage" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt=""></div>
                <div class="viewer-label" id="viewerLabel"></div>
            </div>
            <div class="viewer-hint" id="viewerHint">点击图片切换表情</div>
            <div class="viewer-dots" id="viewerDots"></div>
        </div>
    </div>
    
    <!-- 视频播放器弹窗 - B站嵌入 -->
    <div class="video-player-modal" id="videoPlayerModal">
        <div class="video-player-container">
            <button class="video-close-btn" id="videoCloseBtn"></button>
            <iframe id="videoPlayer" src="" allowfullscreen="true" allow="autoplay"></iframe>
        </div>
    </div>
    
    <!-- 底部触发区域 -->
    <div class="audio-trigger" id="audioTrigger"></div>
    
    <!-- 底部提示小物件 -->
    <div class="bottom-hint" id="bottomHint"></div>
    
    <div class="audio-control" id="audioControl">
        <button class="play-btn" id="playBtn">
            <svg id="playIcon" viewBox="0 0 24 24"><polygon points="5,3 19,12 5,21"/></svg>
            <svg id="pauseIcon" viewBox="0 0 24 24" style="display:none;"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
        </button>
        <div class="progress-container" id="progressContainer"><div class="progress-fill" id="progressFill"></div></div>
        <div class="time-display" id="timeDisplay">0:00 / 0:00</div>
    </div>
    
    <audio id="bgMusic" preload="auto"><source src="音乐/虚空的造型 remix1.mp3" type="audio/mpeg"></audio>
</body>
</html>
<style>
    /* ==================== 相册样式 ==================== */
    .album-mode {
        position: fixed; inset: 0;
        background: linear-gradient(135deg, #1a1210 0%, #0d0a09 50%, #1a1210 100%);
        z-index: 800; opacity: 0; pointer-events: none; visibility: hidden;
        transition: opacity 1.5s ease, visibility 0s 1.5s;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        perspective: 2000px;
        padding-bottom: 100px;
        overflow: hidden;
    }
    .album-mode.active { opacity: 1; pointer-events: auto; visibility: visible; transition: opacity 1.5s ease, visibility 0s 0s; }
    
    /* 相册背景动画容器 */
    .album-bg-effects {
        position: absolute;
        inset: 0;
        pointer-events: none;
        overflow: hidden;
    }
    
    /* 老旧胶片颗粒感 */
    .album-film-grain {
        position: absolute;
        inset: 0;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%' height='100%' filter='url(%23noise)'/%3E%3C/svg%3E");
        opacity: 0.03;
        animation: albumGrainFlicker 0.5s steps(1) infinite;
    }
    
    @keyframes albumGrainFlicker {
        0%, 100% { opacity: 0.03; }
        50% { opacity: 0.04; }
    }
    
    /* 怀旧暖色光晕 - 像老照片的褪色感 */
    .album-warm-glow {
        position: absolute;
        border-radius: 50%;
        filter: blur(100px);
        mix-blend-mode: soft-light;
    }
    
    .album-warm-glow-1 {
        width: 600px;
        height: 600px;
        background: radial-gradient(circle, rgba(180,120,80,0.15) 0%, transparent 70%);
        left: -200px;
        top: -200px;
        animation: albumWarmPulse 12s ease-in-out infinite;
    }
    
    .album-warm-glow-2 {
        width: 500px;
        height: 500px;
        background: radial-gradient(circle, rgba(139,69,50,0.12) 0%, transparent 70%);
        right: -150px;
        bottom: -100px;
        animation: albumWarmPulse 15s ease-in-out infinite;
        animation-delay: -5s;
    }
    
    @keyframes albumWarmPulse {
        0%, 100% { transform: scale(1); opacity: 0.6; }
        50% { transform: scale(1.1); opacity: 0.8; }
    }
    
    /* 飘落的花瓣/羽毛 */
    .album-petal {
        position: absolute;
        width: 12px;
        height: 18px;
        background: linear-gradient(135deg, rgba(196,30,58,0.6) 0%, rgba(139,0,0,0.4) 100%);
        border-radius: 50% 0 50% 50%;
        opacity: 0;
        animation: albumPetalFall 20s ease-in-out infinite;
        filter: blur(0.5px);
    }
    
    .album-petal:nth-child(1) { left: 5%; animation-delay: 0s; }
    .album-petal:nth-child(2) { left: 15%; animation-delay: -4s; width: 10px; height: 15px; }
    .album-petal:nth-child(3) { left: 25%; animation-delay: -8s; }
    .album-petal:nth-child(4) { left: 40%; animation-delay: -2s; width: 8px; height: 12px; }
    .album-petal:nth-child(5) { left: 55%; animation-delay: -12s; }
    .album-petal:nth-child(6) { left: 70%; animation-delay: -6s; width: 14px; height: 20px; }
    .album-petal:nth-child(7) { left: 85%; animation-delay: -10s; width: 9px; height: 14px; }
    .album-petal:nth-child(8) { left: 95%; animation-delay: -16s; }
    
    @keyframes albumPetalFall {
        0% {
            top: -5%;
            opacity: 0;
            transform: rotate(0deg) translateX(0);
        }
        10% {
            opacity: 0.7;
        }
        50% {
            transform: rotate(180deg) translateX(50px);
        }
        90% {
            opacity: 0.5;
        }
        100% {
            top: 105%;
            opacity: 0;
            transform: rotate(360deg) translateX(-30px);
        }
    }
    
    /* 漂浮的光点 - 像记忆的碎片 */
    .album-memory-light {
        position: absolute;
        width: 6px;
        height: 6px;
        background: radial-gradient(circle, rgba(255,220,180,0.8) 0%, rgba(196,30,58,0.3) 50%, transparent 70%);
        border-radius: 50%;
        animation: albumMemoryFloat 25s ease-in-out infinite;
    }
    
    .album-memory-light:nth-child(1) { left: 8%; top: 30%; animation-delay: 0s; }
    .album-memory-light:nth-child(2) { left: 20%; top: 70%; animation-delay: -5s; width: 4px; height: 4px; }
    .album-memory-light:nth-child(3) { left: 35%; top: 20%; animation-delay: -10s; }
    .album-memory-light:nth-child(4) { left: 65%; top: 80%; animation-delay: -15s; width: 8px; height: 8px; }
    .album-memory-light:nth-child(5) { left: 80%; top: 40%; animation-delay: -20s; }
    .album-memory-light:nth-child(6) { left: 92%; top: 60%; animation-delay: -8s; width: 5px; height: 5px; }
    
    @keyframes albumMemoryFloat {
        0%, 100% {
            transform: translate(0, 0) scale(1);
            opacity: 0.3;
        }
        25% {
            transform: translate(20px, -30px) scale(1.5);
            opacity: 0.8;
        }
        50% {
            transform: translate(-15px, 20px) scale(0.8);
            opacity: 0.5;
        }
        75% {
            transform: translate(25px, 10px) scale(1.2);
            opacity: 0.6;
        }
    }
    
    /* 柔和的边缘暗角 - 老照片效果 */
    .album-vignette {
        position: absolute;
        inset: 0;
        background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.4) 100%);
        pointer-events: none;
    }
    
    /* 微妙的光线射入效果 */
    .album-light-ray {
        position: absolute;
        top: -50%;
        right: 10%;
        width: 300px;
        height: 150%;
        background: linear-gradient(180deg, 
            rgba(255,220,180,0.03) 0%, 
            rgba(255,200,150,0.02) 50%, 
            transparent 100%);
        transform: rotate(15deg);
        filter: blur(30px);
        animation: albumLightRayPulse 10s ease-in-out infinite;
    }
    
    @keyframes albumLightRayPulse {
        0%, 100% { opacity: 0.5; }
        50% { opacity: 0.8; }
    }
    
    /* ==================== 书桌装饰元素 ==================== */
    
    /* 复古钢笔 - 竖着紧靠相册右侧 */
    .desk-pen {
        position: absolute;
        top: 50%;
        right: calc(50% - 570px);
        transform: translateY(-50%) rotate(-91deg) rotateX(5deg);
        transform-style: preserve-3d;
        width: 320px;
        height: 20px;
        background: linear-gradient(180deg, 
            #2a0a0a 0%,
            #4a1515 15%,
            #2a0a0a 30%,
            #4a1515 50%,
            #2a0a0a 70%,
            #4a1515 85%,
            #2a0a0a 100%);
        border-radius: 10px;
        box-shadow: 
            4px 4px 14px rgba(0,0,0,0.5),
            inset 0 3px 5px rgba(255,255,255,0.12),
            inset 0 -3px 5px rgba(0,0,0,0.3);
        opacity: 0.9;
        z-index: 15;
        overflow: visible;
    }
    
    /* 笔帽金属环 - 银色 */
    .desk-pen::before {
        content: '';
        position: absolute;
        left: -2px;
        top: -2px;
        width: 60px;
        height: 24px;
        background: linear-gradient(180deg,
            #a0a0a0 0%,
            #e8e8e8 20%,
            #c0c0c0 40%,
            #909090 60%,
            #c0c0c0 80%,
            #e8e8e8 100%);
        border-radius: 10px 0 0 10px;
        box-shadow: 
            inset 0 3px 4px rgba(255,255,255,0.6),
            inset 0 -3px 4px rgba(0,0,0,0.2);
    }
    /* 笔尖 - 银色 */
    .desk-pen::after {
        content: '';
        position: absolute;
        right: -30px;
        top: 50%;
        transform: translateY(-50%);
        width: 0;
        height: 0;
        border-left: 30px solid #c0c0c0;
        border-top: 8px solid transparent;
        border-bottom: 8px solid transparent;
        filter: drop-shadow(2px 0 2px rgba(0,0,0,0.3));
    }
    
    /* 相册书本容器 - 固定尺寸，不做缩放 */
    .album-book {
        position: relative;
        width: 1200px; height: 700px;
        transform-style: preserve-3d;
        transform: rotateX(5deg) translateX(-300px);
        transition: transform 0.6s ease;
        z-index: 10;
    }
    
    /* 展开后：移回中心位置 */
    .album-book.opened {
        transform: rotateX(5deg) translateX(0);
    }
    
    /* 封底（A反面） - 不再需要，由cover-back代替 */
    .book-back-cover {
        display: none;
    }
    
    /* 最后一页底层 - 封底右侧（当所有内页翻完后显示） */
    .book-last-page {
        position: absolute;
        right: 0; top: 0;
        width: 50%; height: 100%;
        background: linear-gradient(135deg, #2a1a18 0%, #1a0a08 100%);
        border: 3px solid #3a2a28;
        border-radius: 0 8px 8px 0;
        box-shadow: inset 0 0 50px rgba(0,0,0,0.5);
        opacity: 0;
        pointer-events: none;
        z-index: 0; /* 最底层，会被未翻的内页覆盖 */
    }
    
    .album-book.opened .book-last-page {
        opacity: 1;
    }
    
    /* 封面（A正面+A反面） - 初始覆盖右半部分 */
    .book-cover {
        position: absolute;
        right: 0; top: 0;
        width: 50%; height: 100%;  /* 始终是50%宽度 */
        transform-style: preserve-3d;
        transform-origin: left center;
        cursor: pointer;
        z-index: 200;
        transition: transform 0.8s cubic-bezier(0.645, 0.045, 0.355, 1);
    }
    
    .album-book.opened .book-cover {
        transform: rotateY(-180deg);
        pointer-events: none;
        z-index: 1; /* 翻开后降到最底层，让内页能覆盖它 */
    }
    
    .cover-front, .cover-back {
        position: absolute;
        width: 100%; height: 100%;
        backface-visibility: hidden;
        border-radius: 0 8px 8px 0;
    }
    
    .cover-front {
        background: linear-gradient(135deg, #2a1a18 0%, #1a0a08 100%);
        border: 3px solid #3a2a28;
        box-shadow: inset 0 0 50px rgba(0,0,0,0.5), 5px 5px 20px rgba(0,0,0,0.5);
    }
    
    .cover-back {
        background: linear-gradient(135deg, #1a0a08 0%, #2a1a18 100%);
        border: 3px solid #3a2a28;
        transform: rotateY(180deg);
        border-radius: 8px 0 0 8px;
    }
    
    /* 目录页样式 */
    .toc-content {
        position: absolute; inset: 25px;
        border: 2px solid #c41e3a;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        background: linear-gradient(180deg, rgba(196,30,58,0.1) 0%, transparent 100%);
        padding: 30px;
    }
    
    .toc-deco {
        position: absolute; width: 30px; height: 30px;
        border: 2px solid #c41e3a;
    }
    .toc-deco.top-left { top: 10px; left: 10px; border-right: none; border-bottom: none; }
    .toc-deco.top-right { top: 10px; right: 10px; border-left: none; border-bottom: none; }
    .toc-deco.bottom-left { bottom: 10px; left: 10px; border-right: none; border-top: none; }
    .toc-deco.bottom-right { bottom: 10px; right: 10px; border-left: none; border-top: none; }
    
    .toc-title {
        font-size: 1.6rem;
        color: #fff;
        letter-spacing: 0.5em;
        text-shadow: 2px 2px 0 #8b0000;
        margin-bottom: 20px;
    }
    
    .toc-line {
        width: 100px;
        height: 2px;
        background: linear-gradient(90deg, transparent, #c41e3a, transparent);
        margin-bottom: 40px;
    }
    
    .toc-items {
        display: flex;
        flex-direction: column;
        gap: 25px;
        width: 80%;
        max-width: 300px;
    }
    
    .toc-item {
        display: flex;
        align-items: center;
        gap: 15px;
        color: #d4c4b0;
        font-size: 1.1rem;
        letter-spacing: 0.2em;
    }
    
    .toc-item-icon {
        color: #c41e3a;
        font-size: 0.8rem;
    }
    
    .toc-item-text {
        white-space: nowrap;
    }
    
    .toc-item-dots {
        flex: 1;
        border-bottom: 1px dotted rgba(196,30,58,0.5);
        margin: 0 10px;
        height: 1px;
    }
    
    .toc-item-page {
        color: #c41e3a;
        font-size: 0.9rem;
        font-family: 'Georgia', serif;
    }
    
    .toc-footer {
        position: absolute;
        bottom: 30px;
        font-size: 0.7rem;
        color: #666;
        letter-spacing: 0.4em;
    }
    
    /* 扉页样式 */
    .section-title-page {
        display: flex !important;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #f5f0e8;
        grid-template-columns: none !important;
        grid-template-rows: none !important;
    }
    
    .section-title-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 40px;
    }
    
    .section-title-deco {
        width: 60px;
        height: 2px;
        background: linear-gradient(90deg, transparent, #c41e3a, transparent);
        margin-bottom: 30px;
    }
    
    .section-title-main {
        font-size: 2.5rem;
        color: #2a1a18;
        letter-spacing: 0.5em;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        margin-bottom: 15px;
    }
    
    .section-title-sub {
        font-size: 0.9rem;
        color: #888;
        letter-spacing: 0.3em;
        text-transform: uppercase;
    }
    
    .section-title-line {
        width: 80px;
        height: 1px;
        background: #c41e3a;
        margin-top: 30px;
    }
    
    .section-title-icon {
        font-size: 1.5rem;
        color: #c41e3a;
        margin-top: 25px;
    }
    
    .cover-content {
        position: absolute; inset: 25px;
        border: 2px solid #c41e3a;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        background: linear-gradient(180deg, rgba(196,30,58,0.1) 0%, transparent 100%);
    }
    
    .cover-deco {
        position: absolute; width: 30px; height: 30px;
        border: 2px solid #c41e3a;
    }
    .cover-deco.top-left { top: 10px; left: 10px; border-right: none; border-bottom: none; }
    .cover-deco.top-right { top: 10px; right: 10px; border-left: none; border-bottom: none; }
    .cover-deco.bottom-left { bottom: 10px; left: 10px; border-right: none; border-top: none; }
    .cover-deco.bottom-right { bottom: 10px; right: 10px; border-left: none; border-top: none; }
    
    .cover-title { font-size: 1.8rem; color: #fff; letter-spacing: 0.3em; text-shadow: 2px 2px 0 #8b0000; margin-bottom: 15px; }
    .cover-subtitle { font-size: 0.9rem; color: #c41e3a; letter-spacing: 0.5em; }
    .cover-line { width: 120px; height: 2px; background: linear-gradient(90deg, transparent, #c41e3a, transparent); margin: 25px 0; }
    .cover-hint { font-size: 0.75rem; color: #666; letter-spacing: 0.3em; }
    
    /* 可翻动的内页容器 - 始终可见，尺寸固定 */
    .flippable-pages {
        position: absolute;
        left: 50%; top: 0; /* 从中间开始，这样翻转后反面在左侧 */
        width: 50%; height: 100%;
        transform-style: preserve-3d;
        z-index: 50;
        pointer-events: none;
        opacity: 0;
        visibility: hidden;
        /* 关闭时延迟隐藏，等封面翻回动画完成后再隐藏 */
        transition: opacity 0.3s ease 0.5s, visibility 0s 0.8s;
    }
    
    .album-book.opened .flippable-pages {
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
        /* 打开时延迟显示，等封面翻转动画过半后再显示内页 */
        transition: opacity 0.3s ease 0.5s, visibility 0s 0.5s;
    }
    
    .flippable-page {
        position: absolute;
        width: 100%; height: 100%;
        transform-style: preserve-3d;
        transform-origin: left center; /* 从左边缘翻转 */
        transition: transform 0.8s cubic-bezier(0.645, 0.045, 0.355, 1);
    }
    
    .flippable-page.flipped {
        transform: rotateY(-180deg);
    }
    
    .page-front, .page-back {
        position: absolute;
        width: 100%; height: 100%;
        backface-visibility: hidden;
        background: #f5f0e8;
        padding: 20px;
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        grid-template-rows: repeat(2, 1fr);
        gap: 12px;
    }
    
    .page-front {
        border-radius: 0 8px 8px 0;
        box-shadow: inset 10px 0 30px rgba(0,0,0,0.1), 2px 0 10px rgba(0,0,0,0.1);
        /* 正面稍微向前偏移，确保在3D空间中不被反面遮挡 */
        transform: translateZ(1px);
    }
    
    .page-back {
        /* 反面旋转180度并稍微向后偏移 */
        transform: rotateY(180deg) translateZ(1px);
        border-radius: 8px 0 0 8px;
        box-shadow: inset -10px 0 30px rgba(0,0,0,0.1), -2px 0 10px rgba(0,0,0,0.1);
    }
    
    /* 照片槽位 */
    .photo-slot {
        position: relative;
        background: #fff;
        border: 1px solid #e0d8d0;
        padding: 8px 8px 28px 8px;
        cursor: pointer;
        /* 分离 transform 和其他属性的过渡时间 */
        transition: box-shadow 0.3s ease, z-index 0s;
        box-shadow: 2px 2px 8px rgba(0,0,0,0.1);
        overflow: hidden;
    }
    
    .photo-slot:hover {
        /* 移除 transform 动画，避免与点击事件冲突 */
        box-shadow: 5px 5px 20px rgba(0,0,0,0.2);
        z-index: 10;
    }
    
    .photo-slot-inner {
        width: 100%; 
        height: calc(100% - 0px);
        position: relative; 
        overflow: hidden;
        background: #e8ddd0;
    }
    
    .photo-slot-inner img {
        width: 100%; height: 100%;
        object-fit: cover;
        transition: transform 0.3s ease;
    }
    
    .photo-slot:hover .photo-slot-inner img { 
        /* 保留图片的缩放效果，但不影响点击 */
        transform: scale(1.05); 
    }
    
    .photo-slot-label {
        position: absolute;
        bottom: 8px; left: 0; width: 100%;
        text-align: center;
        font-size: 0.7rem; color: #888;
        letter-spacing: 0.1em;
    }
    
    .photo-slot-count {
        position: absolute;
        top: 12px; right: 12px;
        background: #c41e3a; color: #fff;
        font-size: 0.65rem;
        padding: 2px 6px;
        border-radius: 8px;
        opacity: 0;
        transition: opacity 0.3s ease;
    }
    
    .photo-slot:hover .photo-slot-count { opacity: 1; }
    
    .photo-slot.empty {
        background: #ebe5dd;
        cursor: default;
        opacity: 0.5;
    }
    .photo-slot.empty:hover { transform: none; box-shadow: 2px 2px 8px rgba(0,0,0,0.1); }
    
    /* 相册导航 */
    .album-nav {
        position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%);
        display: flex; align-items: center; gap: 30px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.5s ease;
        z-index: 900; /* 确保在播放器之上 */
    }
    
    .album-nav.visible {
        opacity: 1;
        pointer-events: auto;
    }
    
    .album-nav-btn {
        background: transparent;
        border: 1px solid rgba(196,30,58,0.5);
        color: #c41e3a;
        padding: 12px 25px;
        font-size: 0.9rem;
        cursor: pointer;
        transition: all 0.3s ease;
        letter-spacing: 0.1em;
        font-family: inherit;
    }
    
    .album-nav-btn:hover {
        background: rgba(196,30,58,0.2);
        border-color: #c41e3a;
        box-shadow: 0 0 20px rgba(196,30,58,0.3);
    }
    
    .album-nav-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .album-page-indicator { color: #888; font-size: 0.9rem; letter-spacing: 0.2em; min-width: 100px; text-align: center; }
    
    /* ==================== 视频内页样式 - 复古胶片风格 ==================== */
    .video-content-page {
        display: flex !important;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 20px;
        padding: 25px;
        box-sizing: border-box;
        background: linear-gradient(180deg, #f5f0e8 0%, #ebe5dd 100%);
    }
    
    /* 视频卡片 - 复古胶片风格 */
    .video-slot {
        position: relative;
        width: 90%;
        max-width: 480px;
        height: calc(50% - 20px);
        background: #fff;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 3px 3px 15px rgba(0,0,0,0.15);
        overflow: hidden;
        box-sizing: border-box;
        border: 1px solid #e0d8d0;
    }
    
    /* 胶片孔装饰 - 左右两侧 */
    .video-slot::before,
    .video-slot::after {
        content: '';
        position: absolute;
        top: 4px;
        bottom: 44px; /* 避开底部40px的信息栏 */
        width: 6px;
        background: repeating-linear-gradient(
            180deg,
            transparent 0px,
            transparent 8px,
            rgba(196,30,58,0.15) 8px,
            rgba(196,30,58,0.15) 16px
        );
        z-index: 5;
    }
    
    .video-slot::before {
        left: 2px;
    }
    
    .video-slot::after {
        right: 2px;
    }
    
    .video-slot.empty {
        background: rgba(245,240,232,0.8);
        border: 2px dashed #d4c4b0;
        box-shadow: none;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 8px;
    }
    
    .video-slot.empty::before,
    .video-slot.empty::after {
        display: none;
    }
    
    .video-slot:not(.empty):hover {
        transform: translateY(-3px);
        box-shadow: 5px 8px 25px rgba(0,0,0,0.2);
    }
    
    /* 视频封面容器 */
    .video-slot-inner {
        position: relative;
        width: 100%;
        height: calc(100% - 40px); /* 减去底部信息栏高度 */
        background: #2a1a18;
        overflow: hidden;
    }
    
    .video-slot-inner img, .video-slot-inner .video-cover {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transition: transform 0.4s ease;
    }
    
    .video-slot:hover .video-slot-inner img {
        transform: scale(1.05);
    }
    
    /* 播放按钮覆盖层 */
    .video-play-overlay {
        position: absolute;
        inset: 0;
        background: linear-gradient(180deg, rgba(42,26,24,0.1) 0%, rgba(42,26,24,0.4) 100%);
        display: flex;
        justify-content: center;
        align-items: center;
        transition: background 0.3s ease;
    }
    
    .video-slot:hover .video-play-overlay {
        background: linear-gradient(180deg, rgba(42,26,24,0.2) 0%, rgba(42,26,24,0.5) 100%);
    }
    
    /* 播放图标 */
    .video-play-icon {
        width: 60px;
        height: 60px;
        background: rgba(196,30,58,0.9);
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        box-shadow: 0 0 30px rgba(196,30,58,0.6), 0 0 60px rgba(196,30,58,0.3);
        transition: all 0.3s ease;
        border: 3px solid rgba(255,255,255,0.3);
    }
    
    .video-slot:hover .video-play-icon {
        transform: scale(1.15);
        box-shadow: 0 0 40px rgba(196,30,58,0.8), 0 0 80px rgba(196,30,58,0.4);
        background: rgba(196,30,58,1);
    }
    
    .video-play-icon::after {
        content: '';
        width: 0;
        height: 0;
        border-left: 24px solid #fff;
        border-top: 15px solid transparent;
        border-bottom: 15px solid transparent;
        margin-left: 6px;
    }
    
    /* 视频信息栏 - 底部暖色条 */
    .video-slot-info {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 40px;
        background: linear-gradient(180deg, #f5ebe0 0%, #e8ddd0 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0 15px;
        border-top: 1px solid #d4c4b0;
    }
    
    .video-slot-label {
        font-size: 0.85rem;
        color: #8b7355;
        letter-spacing: 0.15em;
        font-family: 'Consolas', 'Monaco', monospace;
    }
    
    /* 视频时长标签（装饰用） */
    .video-duration {
        position: absolute;
        bottom: 50px;
        right: 10px;
        background: rgba(139,115,85,0.85);
        color: #fff;
        font-size: 0.75rem;
        padding: 3px 8px;
        border-radius: 3px;
        font-family: 'Consolas', 'Monaco', monospace;
        letter-spacing: 0.05em;
    }
    
    /* B站备用封面logo */
    .bilibili-logo-fallback {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        text-align: center;
        pointer-events: none;
        z-index: 5;
    }
    
    /* 视频封面加载动画 */
    .video-loading {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #fff;
        z-index: 10;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }
    
    .video-loading-bars {
        display: flex;
        align-items: flex-end;
        gap: 8px;
        height: 60px;
        margin-bottom: 20px;
    }
    
    .video-loading-bar {
        width: 8px;
        height: 40px;
        border-radius: 4px;
        animation: videoBarJump 1s ease-in-out infinite;
    }
    
    .video-loading-bar:nth-child(1) {
        background: #8b0000;
        animation-delay: 0s;
    }
    
    .video-loading-bar:nth-child(2) {
        background: #a52a2a;
        animation-delay: 0.1s;
    }
    
    .video-loading-bar:nth-child(3) {
        background: #c41e3a;
        animation-delay: 0.2s;
    }
    
    .video-loading-bar:nth-child(4) {
        background: #e85d75;
        animation-delay: 0.3s;
    }
    
    .video-loading-bar:nth-child(5) {
        background: #fff;
        border: 1px solid #ddd;
        animation-delay: 0.4s;
    }
    
    .video-loading-text {
        font-size: 0.9rem;
        color: #666;
        letter-spacing: 0.3em;
        font-weight: 500;
    }
    
    @keyframes videoBarJump {
        0%, 100% {
            transform: translateY(0);
        }
        50% {
            transform: translateY(-20px);
        }
    }
    
    /* 隐藏loading */
    .video-loading.hidden {
        display: none;
    }
    
    /* 反面装饰槽位 */
    .empty-slot-decoration {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        color: #888;
        font-size: 0.9rem;
        letter-spacing: 0.2em;
    }
    
    /* ==================== 文字板块样式 ==================== */
    .text-content-page {
        display: flex !important;
        flex-direction: column;
        padding: 35px 40px;
        box-sizing: border-box;
        background: linear-gradient(180deg, #faf8f5 0%, #f5f0e8 100%);
        overflow: hidden;
    }
    
    /* 文章容器 */
    .article-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }
    
    /* 文章标题 */
    .article-title {
        font-size: 1.4rem;
        color: #2a1a18;
        letter-spacing: 0.2em;
        text-align: center;
        margin-bottom: 8px;
        font-weight: 600;
    }
    
    /* 文章副标题/作者 */
    .article-subtitle {
        font-size: 0.75rem;
        color: #999;
        text-align: center;
        letter-spacing: 0.15em;
        margin-bottom: 15px;
    }
    
    /* 文章分隔线 */
    .article-divider {
        width: 60px;
        height: 1px;
        background: linear-gradient(90deg, transparent, #c41e3a, transparent);
        margin: 0 auto 20px;
    }
    
    /* 文章正文 */
    .article-content {
        flex: 1;
        font-size: 0.85rem;
        color: #4a4a4a;
        line-height: 2;
        text-align: justify;
        overflow-y: auto;
        padding-right: 10px;
        letter-spacing: 0.05em;
    }
    
    .article-content::-webkit-scrollbar {
        width: 4px;
    }
    
    .article-content::-webkit-scrollbar-track {
        background: rgba(0,0,0,0.05);
        border-radius: 2px;
    }
    
    .article-content::-webkit-scrollbar-thumb {
        background: rgba(196,30,58,0.3);
        border-radius: 2px;
    }
    
    .article-content p {
        text-indent: 2em;
        margin-bottom: 1em;
    }
    
    .article-content p:last-child {
        margin-bottom: 0;
    }
    
    /* 文章页脚 */
    .article-footer {
        margin-top: 15px;
        padding-top: 10px;
        border-top: 1px solid rgba(196,30,58,0.2);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .article-number {
        font-size: 0.7rem;
        color: #999;
        letter-spacing: 0.1em;
        font-family: 'Georgia', serif;
    }
    
    .article-decoration {
        font-size: 0.8rem;
        color: #c41e3a;
    }

    /* 视频播放器弹窗 */
    .video-player-modal {
        position: fixed;
        inset: 0;
        z-index: 4000;
        display: flex;
        justify-content: center;
        align-items: center;
        background: rgba(0,0,0,0.95);
        opacity: 0;
        pointer-events: none;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0s 0.3s;
    }

    .video-player-modal.active {
        opacity: 1;
        pointer-events: auto;
        visibility: visible;
        transition: opacity 0.3s ease, visibility 0s 0s;
    }
    .video-player-container {
        position: relative;
        width: 90%;
        max-width: 960px;
        aspect-ratio: 16/9;
        background: #000;
        border: 2px solid #c41e3a;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 0 50px rgba(196,30,58,0.5);
    }
    .video-player-container video {
        width: 100%;
        height: 100%;
        background: #000;
    }
    .video-player-container iframe {
        width: 100%;
        height: 100%;
        border: none;
        background: #000;
        border: none;
    }
    .video-close-btn {
        position: absolute;
        top: -50px;
        right: 0;
        width: 40px;
        height: 40px;
        background: transparent;
        border: 2px solid #fff;
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    .video-close-btn:hover {
        background: #c41e3a;
        border-color: #c41e3a;
        transform: rotate(90deg);
    }
    .video-close-btn::before,
    .video-close-btn::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 20px;
        height: 2px;
        background: #fff;
    }
    .video-close-btn::before { transform: translate(-50%, -50%) rotate(45deg); }
    .video-close-btn::after { transform: translate(-50%, -50%) rotate(-45deg); }
</style>
<style>
    /* ==================== 查看器样式 ==================== */
    .viewer {
        position: fixed; inset: 0; z-index: 3000;
        display: flex; justify-content: center; align-items: center;
        opacity: 0; pointer-events: none; visibility: hidden;
        transition: opacity 0.5s ease, visibility 0s 0.5s;
    }
    .viewer.active { opacity: 1; pointer-events: auto; visibility: visible; transition: opacity 0.5s ease, visibility 0s 0s; }
    .viewer-backdrop { position: absolute; inset: 0; background: rgba(0,0,0,0.95); }
    
    .viewer-close {
        position: absolute; top: 30px; right: 30px;
        width: 50px; height: 50px;
        border: 2px solid #fff; background: transparent;
        cursor: pointer; transition: all 0.3s ease; z-index: 10;
    }
    .viewer-close:hover { background: #c41e3a; border-color: #c41e3a; transform: rotate(90deg); }
    .viewer-close::before, .viewer-close::after {
        content: ''; position: absolute; top: 50%; left: 50%;
        width: 25px; height: 2px; background: #fff;
    }
    .viewer-close::before { transform: translate(-50%, -50%) rotate(45deg); }
    .viewer-close::after { transform: translate(-50%, -50%) rotate(-45deg); }
    
    .viewer-content { position: relative; display: flex; flex-direction: column; align-items: center; z-index: 5; }
    
    .viewer-photo-frame {
        background: #f5f0e8;
        padding: 20px 20px 50px 20px;
        box-shadow: 0 0 0 3px #c41e3a, 0 0 0 8px #2a1a18, 0 20px 60px rgba(0,0,0,0.5);
        cursor: pointer;
        transition: transform 0.3s ease;
        position: relative;
    }
    .viewer-photo-frame:hover { transform: scale(1.02); }
    .viewer-photo-frame:active { transform: scale(0.98); }
    
    .viewer-photo-mat { 
        background: #1a1a1a; 
        padding: 5px; 
        position: relative;
        min-width: 400px;
        min-height: 300px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .viewer-image { 
        max-width: 70vw; 
        max-height: 60vh; 
        display: block;
        /* 移除 transition，避免与查看器的淡入动画冲突 */
    }
    /* 图片加载中的状态 */
    .viewer-image.loading {
        opacity: 0;
    }
    .viewer-label { position: absolute; bottom: 15px; left: 0; width: 100%; text-align: center; font-size: 0.9rem; color: #666; letter-spacing: 0.15em; }
    .viewer-hint { margin-top: 20px; font-size: 0.85rem; color: #666; letter-spacing: 0.1em; opacity: 0; transition: opacity 0.3s ease; }
    .viewer.active .viewer-hint { opacity: 1; transition-delay: 0.5s; }
    
    .viewer-dots { display: flex; gap: 10px; margin-top: 15px; }
    .viewer-dot {
        width: 10px; height: 10px;
        border: 2px solid #c41e3a; border-radius: 50%;
        background: transparent;
        transition: all 0.3s ease; cursor: pointer;
    }
    .viewer-dot.active { background: #c41e3a; box-shadow: 0 0 10px #c41e3a; }
    .viewer-dot:hover { transform: scale(1.2); }
    
    /* 动画关键帧 */
    @keyframes fadeOut { to { opacity: 0; } }
    @keyframes typeChar { to { opacity: 1; } }
    @keyframes waveChar { 0% { opacity: 0; transform: translateY(30px) rotate(10deg); } 100% { opacity: 1; transform: translateY(0) rotate(0); } }
    @keyframes glitchText { 0% { opacity: 0; transform: translate(-10px, 0); } 20% { opacity: 1; transform: translate(5px, -2px); } 100% { transform: translate(0, 0); } }
    @keyframes blurIn { to { filter: blur(0); opacity: 1; } }
    @keyframes rotate3dIn { to { transform: perspective(500px) rotateX(0); } }
    @keyframes scatterIn { to { opacity: 1; transform: translate(0, 0) rotate(0); } }
    @keyframes blurOut { to { filter: blur(20px); opacity: 0; } }
    
    @keyframes imgSlideLeft { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
    @keyframes imgSlideRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
    @keyframes imgSlideUp { from { transform: translateY(100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    @keyframes imgZoomIn { from { transform: scale(0.3); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    @keyframes imgZoomOut { from { transform: scale(1.8); opacity: 0; filter: blur(10px); } to { transform: scale(1); opacity: 1; filter: blur(0); } }
    @keyframes imgFlipX { from { transform: perspective(1000px) rotateY(-90deg); opacity: 0; } to { transform: perspective(1000px) rotateY(0); opacity: 1; } }
    @keyframes imgCircleReveal { 0% { clip-path: circle(0% at 50% 50%); } 100% { clip-path: circle(75% at 50% 50%); } }
    @keyframes imgDiagonalReveal { 0% { clip-path: polygon(0 0, 0 0, 0 100%, 0 100%); } 100% { clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%); } }
    @keyframes imgGlitchIn { 0% { opacity: 0; transform: translate(-20px, 10px); filter: hue-rotate(90deg); } 20% { opacity: 1; transform: translate(10px, -5px); filter: hue-rotate(0); } 100% { transform: translate(0, 0); } }
    @keyframes imgBounceIn { 0% { transform: scale(0); } 50% { transform: scale(1.15); } 100% { transform: scale(1); } }
    @keyframes imgSwingIn { 0% { transform: rotate(-30deg) translateY(-100px); opacity: 0; } 100% { transform: rotate(0) translateY(0); opacity: 1; } }
    @keyframes imgFloat { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }
    @keyframes imgPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.03); } }
    @keyframes imgKenBurns { 0% { transform: scale(1) translate(0, 1%); } 100% { transform: scale(1.15) translate(-3%, -2%); } }
    @keyframes imgKenBurns2 { 0% { transform: scale(1) translate(0, 2%); } 100% { transform: scale(1.15) translate(-3%, -1%); } }
    @keyframes montageRippleExpand {
        0% { width: 0; height: 0; opacity: 1; }
        100% { width: 150vmax; height: 150vmax; opacity: 0; }
    }
    @keyframes imgSway { 0%, 100% { transform: rotate(-2deg); } 50% { transform: rotate(2deg); } }
    @keyframes imgBreath { 0%, 100% { transform: scale(1); filter: brightness(1); } 50% { transform: scale(1.02); filter: brightness(1.1); } }
    
    /* 场景10镜子破碎动画 */
    @keyframes mirrorCrackGrow { 
        0% { height: 0; opacity: 0; } 
        100% { height: var(--crack-length, 50%); opacity: 1; } 
    }
    @keyframes mirrorImpact {
        0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
        50% { transform: translate(-50%, -50%) scale(3); opacity: 0.8; }
        100% { transform: translate(-50%, -50%) scale(5); opacity: 0; }
    }
    @keyframes mirrorShatter {
        0% { transform: translate(0, 0) rotate(var(--angle, 0deg)) scale(1); opacity: 1; }
        70% { opacity: 0.8; }
        100% { transform: translate(var(--offset-x, 0), var(--offset-y, 0)) rotate(calc(var(--angle, 0deg) + 180deg)) scale(0.3); opacity: 0; }
    }
    @keyframes mirrorShatterFlash {
        0% { opacity: 0.8; }
        50% { opacity: 0.4; }
        100% { opacity: 0; }
    }
    @keyframes mirrorShake {
        0%, 100% { transform: translate(0, 0); }
        10% { transform: translate(-2px, 2px); }
        20% { transform: translate(2px, -2px); }
        30% { transform: translate(-2px, -2px); }
        40% { transform: translate(2px, 2px); }
        50% { transform: translate(-1px, 1px); }
        60% { transform: translate(1px, -1px); }
        70% { transform: translate(-1px, -1px); }
        80% { transform: translate(1px, 1px); }
        90% { transform: translate(-0.5px, 0.5px); }
    }
    
    /* 场景10图片运动轨迹（Ken Burns）- 第三张图向下移动2% */
    @keyframes rapidKenBurns1 { 
        0% { transform: scale(1) translate(0, 0); } 
        100% { transform: scale(1.2) translate(-5%, -3%); } 
    }
    @keyframes rapidKenBurns2 { 
        0% { transform: scale(1) translate(0, 0); } 
        100% { transform: scale(1.2) translate(5%, 3%); } 
    }
    @keyframes rapidKenBurns3 { 
        0% { transform: scale(1.1) translate(0, 2%); } 
        100% { transform: scale(1.25) translate(-2%, 4%); } 
    }
    
    @keyframes seqPulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    @keyframes expandW { to { width: 350px; } }
    @keyframes expandH { to { height: 80px; } }
    @keyframes frameZoomToFit { 
        0% { transform: scale(1); } 
        100% { transform: scale(1.6); } 
    }
    
    /* 待机画面提示动画 */
    @keyframes hintFadeIn {
        0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
        100% { opacity: 1; transform: translateX(-50%) translateY(0); }
    }
    @keyframes hintPulse {
        0%, 100% { opacity: 0.6; }
        50% { opacity: 1; }
    }
    
    /* 播放按钮波浪扩散效果 */
    @keyframes rippleExpand {
        0% {
            width: 0;
            height: 0;
            opacity: 1;
        }
        100% {
            width: 250vmax;
            height: 250vmax;
            opacity: 0;
        }
    }
    @keyframes rippleFlash {
        0% {
            transform: translate(-50%, -50%) scale(0.5);
            opacity: 1;
        }
        100% {
            transform: translate(-50%, -50%) scale(2);
            opacity: 0;
        }
    }
    
    /* 场景2标题特效动画 */
    @keyframes burstExpand {
        0% { width: 0; height: 0; opacity: 1; }
        50% { width: 150vw; height: 150vw; opacity: 0.8; }
        100% { width: 200vw; height: 200vw; opacity: 0; }
    }
    @keyframes titleReveal {
        0% { opacity: 0; transform: scale(0.5); filter: blur(20px); }
        30% { opacity: 1; transform: scale(1.1); filter: blur(0); }
        50% { transform: scale(0.95); }
        70% { transform: scale(1.02); }
        100% { opacity: 1; transform: scale(1); filter: blur(0); }
    }
    @keyframes particleFloat {
        0% { opacity: 0; transform: translateY(0) scale(0); }
        20% { opacity: 1; transform: translateY(-20px) scale(1); }
        80% { opacity: 1; transform: translateY(-80px) scale(1); }
        100% { opacity: 0; transform: translateY(-120px) scale(0); }
    }
    @keyframes lineFlash {
        0% { transform: translate(-50%,-50%) rotate(var(--angle, 0deg)) scaleX(0); opacity: 1; }
        50% { transform: translate(-50%,-50%) rotate(var(--angle, 0deg)) scaleX(1); opacity: 1; }
        100% { transform: translate(-50%,-50%) rotate(var(--angle, 0deg)) scaleX(1); opacity: 0; }
    }
    @keyframes borderDraw {
        0% { border-color: transparent; box-shadow: none; }
        25% { border-top-color: #c41e3a; border-right-color: transparent; border-bottom-color: transparent; border-left-color: transparent; }
        50% { border-top-color: #c41e3a; border-right-color: #c41e3a; border-bottom-color: transparent; border-left-color: transparent; }
        75% { border-top-color: #c41e3a; border-right-color: #c41e3a; border-bottom-color: #c41e3a; border-left-color: transparent; }
        100% { border-color: #c41e3a; box-shadow: 0 0 30px rgba(196,30,58,0.5), inset 0 0 30px rgba(196,30,58,0.1); }
    }
    @keyframes stripExpand { to { transform: scaleX(1); } }
    @keyframes stripContract { to { transform: scaleX(0); } }
    @keyframes stripExpandY { to { transform: scaleY(1); } }
    @keyframes stripContractY { to { transform: scaleY(0); } }
    @keyframes radialStripExpand { to { transform: scale(1); } }
    @keyframes radialStripContract { to { transform: scale(1.5); opacity: 0; } }
    @keyframes diagonalStripExpand { to { transform: rotate(45deg) scaleY(1); } }
    @keyframes diagonalStripContract { to { transform: rotate(45deg) scaleY(0); transform-origin: center bottom; } }
    
    /* 呼吸沉淀转场动画 - 从暗红激昂到冷蓝舒缓 */
    @keyframes breathRedContract {
        0% { opacity: 1; transform: scale(1.2); }
        60% { opacity: 0.8; transform: scale(0.3); }
        100% { opacity: 0; transform: scale(0); }
    }
    @keyframes breathParticleIn {
        0% { opacity: 0.8; transform: translate(0, 0) scale(1); }
        100% { opacity: 0; transform: translate(calc(50vw - 50%), calc(50vh - 50%)) scale(0); left: 50%; top: 50%; }
    }
    @keyframes breathCenterFlash {
        0% { width: 0; height: 0; opacity: 0; }
        30% { width: 150vmax; height: 150vmax; opacity: 1; }
        100% { width: 200vmax; height: 200vmax; opacity: 0; }
    }
    @keyframes breathBlueExpand {
        0% { opacity: 0; transform: scale(0.3); }
        50% { opacity: 0.7; transform: scale(1); }
        100% { opacity: 0; transform: scale(1.5); }
    }
    @keyframes breathRipple {
        0% { transform: translate(-50%, -50%) scale(0); opacity: 0.8; }
        100% { transform: translate(-50%, -50%) scale(30); opacity: 0; }
    }
    
    @keyframes finalFlash { 0% { opacity: 0; } 10% { opacity: 1; } 100% { opacity: 0; } }
    @keyframes cyanGlitchSlide { 0% { transform: translateX(-100%); opacity: 0; } 30% { opacity: 1; } 70% { opacity: 1; } 100% { transform: translateX(100%); opacity: 0; } }
    @keyframes worldTear { 0% { clip-path: inset(0 50% 0 50%); } 100% { clip-path: inset(0 0 0 0); } }
    @keyframes tearLine { 0% { height: 0; opacity: 0; } 50% { height: 100%; opacity: 1; } 100% { height: 100%; opacity: 0; } }
    @keyframes photoAppear { 0% { opacity: 0; transform: translateY(20px) rotate(-3deg); } 100% { opacity: 1; transform: translateY(0) rotate(0); } }
    
    /* 光线扫描动画 */
    @keyframes scanLineMove {
        0% { left: -150px; }
        100% { left: calc(100% + 150px); }
    }
    @keyframes scanLineMove2 {
        0% { right: -150px; }
        100% { right: calc(100% + 150px); }
    }
    
    /* 丁达尔光线扫过动画 */
    @keyframes tyndallSweep {
        0% { left: -20%; opacity: 0; }
        10% { opacity: 1; }
        90% { opacity: 1; }
        100% { left: 120%; opacity: 0; }
    }
    
    /* 丁达尔光线效果 - 文字发出的光束 */
    .tyndall-effect {
        position: relative;
        animation: tyndallGlow 0.8s ease-in-out forwards;
    }
    
    .tyndall-effect::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 0;
        width: 100%;
        height: 200%;
        transform: translateY(-50%);
        background: 
            linear-gradient(95deg, transparent 0%, rgba(255,255,255,0) 20%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0) 80%, transparent 100%),
            linear-gradient(100deg, transparent 0%, rgba(196,30,58,0) 30%, rgba(196,30,58,0.1) 50%, rgba(196,30,58,0) 70%, transparent 100%);
        pointer-events: none;
        opacity: 0;
        animation: tyndallRays 0.8s ease-in-out forwards;
        filter: blur(8px);
    }
    
    .tyndall-effect::after {
        content: '';
        position: absolute;
        top: -100%;
        left: -50%;
        width: 200%;
        height: 300%;
        background: 
            conic-gradient(from 180deg at 50% 50%, 
                transparent 0deg,
                rgba(255,255,255,0.03) 15deg,
                transparent 30deg,
                rgba(196,30,58,0.05) 45deg,
                transparent 60deg,
                rgba(255,255,255,0.04) 75deg,
                transparent 90deg,
                rgba(196,30,58,0.03) 105deg,
                transparent 120deg,
                rgba(255,255,255,0.05) 135deg,
                transparent 150deg,
                rgba(196,30,58,0.04) 165deg,
                transparent 180deg,
                rgba(255,255,255,0.03) 195deg,
                transparent 210deg,
                rgba(196,30,58,0.05) 225deg,
                transparent 240deg,
                rgba(255,255,255,0.04) 255deg,
                transparent 270deg,
                rgba(196,30,58,0.03) 285deg,
                transparent 300deg,
                rgba(255,255,255,0.05) 315deg,
                transparent 330deg,
                rgba(196,30,58,0.04) 345deg,
                transparent 360deg
            );
        pointer-events: none;
        opacity: 0;
        animation: tyndallBurst 0.8s ease-in-out forwards;
        filter: blur(3px);
    }
    
    @keyframes tyndallGlow {
        0% { text-shadow: 6px 6px 0 #8b0000, 12px 12px 0 #000; }
        40% { text-shadow: 6px 6px 0 #8b0000, 12px 12px 0 #000, 0 0 50px rgba(196,30,58,1), 0 0 100px rgba(196,30,58,0.7), 0 0 150px rgba(139,0,0,0.5), 0 0 20px rgba(255,255,255,0.3); }
        100% { text-shadow: 6px 6px 0 #8b0000, 12px 12px 0 #000, 0 0 25px rgba(196,30,58,0.4), 0 0 50px rgba(139,0,0,0.2); }
    }
    
    @keyframes tyndallRays {
        0% { opacity: 0; transform: translateY(-50%) scaleX(0.5); }
        30% { opacity: 1; transform: translateY(-50%) scaleX(1.2); }
        100% { opacity: 0; transform: translateY(-50%) scaleX(1.5); }
    }
    
    @keyframes tyndallBurst {
        0% { opacity: 0; transform: scale(0.3) rotate(0deg); }
        40% { opacity: 1; transform: scale(1.2) rotate(15deg); }
        100% { opacity: 0; transform: scale(1.5) rotate(30deg); }
    }
    
    /* 副标题只有辉光效果，没有伪元素光线 */
    .tyndall-glow-only {
        animation: tyndallGlowSubtitle 0.8s ease-in-out forwards;
    }
    
    @keyframes tyndallGlowSubtitle {
        0% { text-shadow: none; }
        40% { text-shadow: 0 0 35px rgba(196,30,58,1), 0 0 70px rgba(139,0,0,0.6), 0 0 10px rgba(255,255,255,0.2); }
        100% { text-shadow: 0 0 18px rgba(196,30,58,0.4), 0 0 35px rgba(139,0,0,0.2); }
    }
    
    /* 丁达尔光线扫过动画 */
    @keyframes tyndallSweep {
        0% { left: -20%; opacity: 0; }
        15% { opacity: 1; }
        85% { opacity: 1; }
        100% { left: 120%; opacity: 0; }
    }
    
    /* 色相分离/RGB偏移动画 */
    @keyframes chromaAberration {
        0% { filter: none; }
        15% { filter: drop-shadow(-3px 0 0 rgba(255,0,0,0.7)) drop-shadow(3px 0 0 rgba(0,255,255,0.7)); }
        30% { filter: drop-shadow(-5px 0 0 rgba(255,0,0,0.9)) drop-shadow(5px 0 0 rgba(0,255,255,0.9)); }
        45% { filter: drop-shadow(-2px 0 0 rgba(255,0,0,0.5)) drop-shadow(2px 0 0 rgba(0,255,255,0.5)); }
        60% { filter: drop-shadow(-4px 0 0 rgba(255,0,0,0.8)) drop-shadow(4px 0 0 rgba(0,255,255,0.8)); }
        75% { filter: drop-shadow(-1px 0 0 rgba(255,0,0,0.3)) drop-shadow(1px 0 0 rgba(0,255,255,0.3)); }
        100% { filter: none; }
    }
    
    /* 全局故障效果 - 画面撕裂+抖动+闪烁 */
    .global-glitch-effect {
        animation: glitchShake 0.1s ease infinite;
    }
    
    .global-glitch-effect::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: 
            linear-gradient(transparent 0%, transparent 20%, rgba(196,30,58,0.1) 20.5%, transparent 21%, transparent 40%, rgba(255,255,255,0.05) 40.5%, transparent 41%, transparent 60%, rgba(196,30,58,0.08) 60.5%, transparent 61%, transparent 80%, rgba(255,255,255,0.03) 80.5%, transparent 81%);
        pointer-events: none;
        z-index: 9999;
        animation: glitchScanlines 0.08s steps(1) infinite;
    }
    
    @keyframes glitchShake {
        0% { transform: translate(0, 0); }
        20% { transform: translate(-3px, 1px); }
        40% { transform: translate(2px, -2px); }
        60% { transform: translate(-1px, 2px); }
        80% { transform: translate(3px, -1px); }
        100% { transform: translate(0, 0); }
    }
    
    @keyframes glitchScanlines {
        0% { opacity: 1; clip-path: inset(0 0 85% 0); }
        25% { opacity: 0.8; clip-path: inset(30% 0 50% 0); }
        50% { opacity: 1; clip-path: inset(60% 0 20% 0); }
        75% { opacity: 0.9; clip-path: inset(10% 0 70% 0); }
        100% { opacity: 1; clip-path: inset(45% 0 35% 0); }
    }
    
    /* 画面撕裂条纹 */
    .glitch-tear-line {
        position: fixed;
        left: 0;
        width: 100%;
        height: 3px;
        background: linear-gradient(90deg, transparent, rgba(196,30,58,0.8), rgba(255,255,255,0.9), rgba(196,30,58,0.8), transparent);
        pointer-events: none;
        z-index: 10000;
        animation: tearLineFlash 0.15s ease-out forwards;
        box-shadow: 0 0 10px rgba(196,30,58,0.8), 0 0 20px rgba(255,255,255,0.5);
    }
    
    @keyframes tearLineFlash {
        0% { opacity: 0; transform: scaleX(0); }
        30% { opacity: 1; transform: scaleX(1.2); }
        100% { opacity: 0; transform: scaleX(1); }
    }
    
    /* 瞬间白屏闪烁 */
    .glitch-flash-overlay {
        position: fixed;
        inset: 0;
        background: rgba(255,255,255,0.9);
        pointer-events: none;
        z-index: 9998;
        animation: flashBurst 0.15s ease-out forwards;
    }
    
    @keyframes flashBurst {
        0% { opacity: 0; }
        20% { opacity: 0.8; }
        100% { opacity: 0; }
    }
    
    /* ==================== 大师级转场动画 ==================== */
    /* 冲击波扩散 */
    @keyframes shockwaveExpand {
        0% { 
            width: 10px; 
            height: 10px; 
            opacity: 1;
        }
        100% { 
            width: 300vw; 
            height: 300vw; 
            opacity: 0;
        }
    }
    
    /* 裂纹扩展 */
    @keyframes crackExpand {
        0% { 
            opacity: 0;
            clip-path: inset(0 100% 0 0);
        }
        20% {
            opacity: 1;
        }
        100% { 
            opacity: 0;
            clip-path: inset(0 0 0 0);
        }
    }
    
    /* 碎片飞散 */
    @keyframes shardFly {
        0% { 
            opacity: 0;
            transform: translate(0, 0) rotate(0deg) scale(0.5);
        }
        20% {
            opacity: 1;
            transform: translate(0, 0) rotate(0deg) scale(1);
        }
        100% { 
            opacity: 0;
            transform: translate(var(--endX), var(--endY)) rotate(var(--rotation)) scale(0.3);
        }
    }
    
    /* 最终闪白淡出 */
    @keyframes finalFlashOut {
        0% { opacity: 1; }
        100% { opacity: 0; }
    }
    
    /* ==================== PV画面歌词样式 ==================== */
    .pv-lyric-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 500;
        overflow: hidden;
    }
    .pv-lyric-overlay.pv-lyric-fadeout {
        animation: pvOverlayFadeout 0.5s ease forwards;
    }
    .pv-custom-line {
        font-weight: 900;
        color: #fff;
        letter-spacing: 0.1em;
        text-shadow: 0 0 30px rgba(196,30,58,0.8), 0 0 60px rgba(196,30,58,0.5), 4px 4px 0 #8b0000;
        white-space: nowrap;
    }
    .pv-glitch-text {
        animation: pvGlitchShake 0.1s ease infinite;
    }
    .pv-glitch-text::before,
    .pv-glitch-text::after {
        content: attr(data-text);
        position: absolute;
        top: 0;
        left: 0;
        opacity: 0.8;
    }
    .pv-glitch-text::before {
        color: #00ffff;
        animation: pvGlitchBefore 0.3s ease infinite;
        clip-path: inset(0 0 50% 0);
    }
    .pv-glitch-text::after {
        color: #ff00ff;
        animation: pvGlitchAfter 0.3s ease infinite;
        clip-path: inset(50% 0 0 0);
    }
    .pv-particle-fall {
        position: absolute;
        top: -10px;
        width: 3px;
        height: 20px;
        background: linear-gradient(180deg, #fff, transparent);
        animation: pvParticleFall 1.5s ease forwards;
    }
    
    @keyframes pvOverlayFadeout {
        to { opacity: 0; }
    }
    @keyframes pvFallDown {
        0% { opacity: 0; transform: translateY(-100px) rotate(-20deg); }
        60% { opacity: 1; transform: translateY(10px) rotate(5deg); }
        100% { opacity: 1; transform: translateY(0) rotate(0); }
    }
    @keyframes pvZoomFadeIn {
        0% { opacity: 0; transform: translateX(-50%) scale(0.3); filter: blur(20px); }
        100% { opacity: 1; transform: translateX(-50%) scale(1); filter: blur(0); }
    }
    @keyframes pvParticleFall {
        0% { opacity: 1; transform: translateY(0); }
        100% { opacity: 0; transform: translateY(100vh); }
    }
    @keyframes pvConverge {
        0% { opacity: 0; }
        100% { opacity: 1; transform: translate(0, 0); }
    }
    @keyframes pvFreezeIn {
        0% { opacity: 0; filter: blur(10px); }
        100% { opacity: 1; filter: blur(0); }
    }
    @keyframes pvGlitchLine {
        0%, 100% { opacity: 0; transform: translateX(-100%); }
        50% { opacity: 1; transform: translateX(100%); }
    }
    @keyframes pvGlitchShake {
        0%, 100% { transform: translateX(-50%) translate(0, 0); }
        25% { transform: translateX(-50%) translate(-2px, 1px); }
        50% { transform: translateX(-50%) translate(2px, -1px); }
        75% { transform: translateX(-50%) translate(-1px, -1px); }
    }
    @keyframes pvGlitchBefore {
        0%, 100% { transform: translate(0); }
        33% { transform: translate(-3px, 2px); }
        66% { transform: translate(3px, -2px); }
    }
    @keyframes pvGlitchAfter {
        0%, 100% { transform: translate(0); }
        33% { transform: translate(3px, -2px); }
        66% { transform: translate(-3px, 2px); }
    }
    @keyframes tulpaCRT_RGB {
        0% { opacity: 1; }
        50% { opacity: 0.8; transform: translateX(calc(var(--shift, 6px) * -1)); }
        100% { opacity: 0; transform: translateX(0); }
    }
    @keyframes tulpaCRT_RGB_Strong {
        0% { opacity: 1; }
        20% { opacity: 1; transform: translateX(-15px) translateY(5px); }
        40% { opacity: 0.8; transform: translateX(20px) translateY(-3px); }
        60% { opacity: 1; transform: translateX(-10px) translateY(2px); }
        80% { opacity: 0.6; transform: translateX(8px) translateY(-2px); }
        100% { opacity: 0; transform: translateX(0) translateY(0); }
    }
    @keyframes tulpaTearSlice {
        0% { opacity: 1; }
        30% { opacity: 1; transform: translateX(var(--offset, 20px)); }
        70% { opacity: 1; transform: translateX(calc(var(--offset, 20px) * -0.5)); }
        100% { opacity: 0; transform: translateX(0); }
    }
    @keyframes tulpaTearSlice_Strong {
        0% { opacity: 1; transform: translateX(0); }
        15% { opacity: 1; transform: translateX(40px); }
        30% { opacity: 1; transform: translateX(-30px); }
        45% { opacity: 1; transform: translateX(25px); }
        60% { opacity: 1; transform: translateX(-15px); }
        80% { opacity: 0.5; transform: translateX(5px); }
        100% { opacity: 0; transform: translateX(0); }
    }
    @keyframes tulpaBlockGlitch {
        0% { opacity: 1; transform: scale(1); }
        33% { opacity: 1; transform: scale(1.5) translate(10px, -5px); }
        66% { opacity: 0.8; transform: scale(0.8) translate(-15px, 8px); }
        100% { opacity: 0; transform: scale(1); }
    }
    @keyframes tulpaCRT_Lines {
        0% { opacity: 1; }
        100% { opacity: 0; }
    }
    @keyframes tulpaNoise {
        0% { opacity: 0.5; transform: translate(0, 0); }
        25% { opacity: 0.3; transform: translate(-3%, 3%); }
        50% { opacity: 0.6; transform: translate(3%, -3%); }
        75% { opacity: 0.4; transform: translate(-2%, -2%); }
        100% { opacity: 0; transform: translate(0, 0); }
    }
    @keyframes tulpaCRT_Flash {
        0% { opacity: 0; }
        10% { opacity: 0.7; }
        20% { opacity: 0; }
        30% { opacity: 0.4; }
        50% { opacity: 0; }
        60% { opacity: 0.2; }
        100% { opacity: 0; }
    }
    @keyframes tulpaCRT_Flash_Strong {
        0% { opacity: 0; }
        8% { opacity: 1; }
        15% { opacity: 0; }
        22% { opacity: 0.9; }
        30% { opacity: 0; }
        38% { opacity: 0.7; }
        50% { opacity: 0; }
        60% { opacity: 0.4; }
        75% { opacity: 0; }
        85% { opacity: 0.2; }
        100% { opacity: 0; }
    }
    @keyframes tulpaBlackout {
        0% { opacity: 0; }
        25% { opacity: 0.8; }
        50% { opacity: 0; }
        75% { opacity: 0.5; }
        100% { opacity: 0; }
    }
    @keyframes tulpaCRT_Shake {
        0% { transform: translate(0, 0) skewX(0); }
        15% { transform: translate(-8px, 0) skewX(2deg); }
        30% { transform: translate(6px, 2px) skewX(-1deg); }
        45% { transform: translate(-4px, -2px) skewX(1deg); }
        60% { transform: translate(3px, 1px) skewX(-0.5deg); }
        75% { transform: translate(-2px, 0) skewX(0.3deg); }
        100% { transform: translate(0, 0) skewX(0); }
    }
    @keyframes tulpaCRT_Shake_Strong {
        0% { transform: translate(0, 0) skewX(0) skewY(0); }
        10% { transform: translate(-15px, 5px) skewX(5deg) skewY(-2deg); }
        20% { transform: translate(12px, -8px) skewX(-4deg) skewY(3deg); }
        30% { transform: translate(-10px, 3px) skewX(3deg) skewY(-1deg); }
        40% { transform: translate(8px, -5px) skewX(-2deg) skewY(2deg); }
        50% { transform: translate(-6px, 4px) skewX(2deg) skewY(-1deg); }
        60% { transform: translate(5px, -3px) skewX(-1deg) skewY(1deg); }
        70% { transform: translate(-3px, 2px) skewX(1deg) skewY(0); }
        80% { transform: translate(2px, -1px) skewX(0) skewY(0); }
        100% { transform: translate(0, 0) skewX(0) skewY(0); }
    }
    @keyframes tulpaHueShift {
        0% { filter: contrast(1.2) saturate(1.1) hue-rotate(0deg); }
        25% { filter: contrast(2) saturate(2) hue-rotate(90deg); }
        50% { filter: contrast(0.5) saturate(0.5) hue-rotate(180deg); }
        75% { filter: contrast(1.5) saturate(1.5) hue-rotate(270deg); }
        100% { filter: contrast(1.2) saturate(1.1) hue-rotate(0deg); }
    }
    @keyframes tulpaCameraShake {
        0%, 100% { transform: translate(0, 0); }
        10% { transform: translate(-5px, 3px); }
        20% { transform: translate(4px, -4px); }
        30% { transform: translate(-3px, 2px); }
        40% { transform: translate(3px, -2px); }
        50% { transform: translate(-2px, 1px); }
        60% { transform: translate(2px, -1px); }
        70% { transform: translate(-1px, 1px); }
        80% { transform: translate(1px, 0); }
    }
    @keyframes pvShadowIn {
        0% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        100% { opacity: var(--final-opacity); transform: translate(-50%, -50%) scale(1); }
    }
    @keyframes pvFadeIn {
        0% { opacity: 0; }
        100% { opacity: 1; }
    }
    @keyframes pvSlideLeft {
        0% { opacity: 0; transform: translateX(100px); }
        100% { opacity: 1; transform: translateX(0); }
    }
    @keyframes pvWaveExpand {
        0% { opacity: 1; transform: translateY(-50%) scale(0.5); }
        100% { opacity: 0; transform: translateY(-50%) scale(2); }
    }
    @keyframes pvRipple {
        0% { opacity: 1; transform: translate(-50%,-50%) scale(0); }
        100% { opacity: 0; transform: translate(-50%,-50%) scale(3); }
    }
    @keyframes pvBigRipple {
        0% { opacity: 1; transform: translate(-50%,-50%) scale(0); }
        100% { opacity: 0; transform: translate(-50%,-50%) scale(15); }
    }
    @keyframes pvMirrorLeft {
        0% { opacity: 0; transform: translateX(-100%) rotateY(-30deg); }
        100% { opacity: 1; transform: translateX(0) rotateY(0); }
    }
    @keyframes pvMirrorRight {
        0% { opacity: 0; transform: translateX(100%) rotateY(30deg); }
        100% { opacity: 1; transform: translateX(0) rotateY(0); }
    }
    @keyframes pvMirrorLine {
        0% { height: 0; }
        100% { height: 60vh; }
    }
    @keyframes pvBloom {
        0% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
        100% { opacity: 1; transform: translate(-50%, -50%) translate(var(--tx, 0), var(--ty, 0)) scale(1); }
    }
    @keyframes pvBloomCenter {
        0% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
        50% { opacity: 1; transform: translate(-50%, -50%) scale(1.5); }
        100% { opacity: 0.5; transform: translate(-50%, -50%) scale(1); }
    }
    @keyframes pvPetalFly {
        0% { opacity: 1; transform: translate(-50%, -50%); }
        100% { opacity: 0; transform: translate(-50%, -50%) rotate(var(--angle)) translateY(-200px); }
    }
    @keyframes pvDance {
        0% { opacity: 0; transform: rotate(var(--start-angle, 0)) translateY(-100px); }
        100% { opacity: 1; transform: rotate(0) translateY(0); }
    }
    @keyframes pvRingSpin {
        0% { transform: translate(-50%, -50%) rotate(0deg); }
        100% { transform: translate(-50%, -50%) rotate(360deg); }
    }
    @keyframes pvRingFadeIn {
        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
        100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }
    @keyframes pvRingBreath {
        0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 0.5; }
        50% { transform: translate(-50%, -50%) scale(1.05) rotate(180deg); opacity: 0.7; }
    }
    @keyframes pvSlashIn {
        0% { opacity: 0; }
        100% { opacity: 1; transform: translateX(0) skewX(0); }
    }
    @keyframes pvSwordSlash {
        0% { height: 0; }
        100% { height: 150vh; }
    }
    @keyframes pvExplodeIn {
        0% { opacity: 0; }
        100% { opacity: 1; transform: scale(1) rotate(0); }
    }
    @keyframes pvTearWorld {
        0% { opacity: 0; transform: translateX(-50%) scaleX(0); }
        50% { opacity: 1; transform: translateX(-50%) scaleX(1.2); }
        100% { opacity: 1; transform: translateX(-50%) scaleX(1); }
    }
    @keyframes pvTearLine {
        0% { height: 0; }
        100% { height: 100vh; }
    }
    @keyframes pvBurst {
        0% { opacity: 1; transform: translate(-50%, -50%); }
        100% { opacity: 0; transform: translate(-50%, -50%) translate(var(--bx), var(--by)); }
    }
    @keyframes pvGlowPulse {
        0% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
        50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
    }
    @keyframes pvBloomCustom {
        0% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
        100% { opacity: 1; transform: translate(calc(-50% + var(--bloom-x)), calc(-50% + var(--bloom-y))) scale(1); }
    }
    @keyframes pvDanceIn {
        0% { opacity: 0; transform: translateY(-80px) rotate(var(--start-rot, 0deg)); }
        100% { opacity: 1; transform: translateY(0) rotate(0deg); }
    }
    @keyframes pvSlideRight {
        0% { opacity: 0; transform: translateX(-100px); }
        100% { opacity: 1; transform: translateX(0); }
    }
    @keyframes pvSlideLeftBig {
        0% { opacity: 0; transform: translateX(100px); }
        100% { opacity: 1; transform: translateX(0); }
    }
    @keyframes pvExplodeChar {
        0% { opacity: 0; transform: scale(2); }
        100% { opacity: 1; transform: scale(1); }
    }
    
    /* ==================== 玻璃碎片3D特效 ==================== */
    .glass-shatter-container {
        position: absolute;
        width: 100%;
        height: 100%;
        perspective: 1800px;
        perspective-origin: 50% 50%;
        overflow: hidden;
        background: radial-gradient(ellipse at center, #1a0a0a 0%, #0a0505 50%, #000 100%);
    }
    
    .glass-3d-space {
        position: absolute;
        width: 100%;
        height: 100%;
        transform-style: preserve-3d;
        animation: glassCarouselRotate 20s linear infinite;
    }
    
    .glass-shard {
        position: absolute;
        left: 50%;
        top: 50%;
        transform-style: preserve-3d;
        backface-visibility: visible;
    }
    
    /* 玻璃碎片内部 - 3D厚度结构 */
    .glass-shard-inner {
        position: relative;
        width: 100%;
        height: 100%;
        transform-style: preserve-3d;
    }
    
    /* 中间的图片层 - 位于玻璃中心 */
    .glass-image-center {
        position: absolute;
        width: 100%;
        height: 100%;
        transform: translateZ(0px);
        overflow: hidden;
        border-radius: 4px;
    }
    
    .glass-image-center img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        filter: contrast(1.15) brightness(1.15);
        opacity: 1 !important;
    }
    
    /* 玻璃正面 - 透明玻璃层 */
    .glass-face-front {
        position: absolute;
        width: 100%;
        height: 100%;
        transform: translateZ(10px);
        border-radius: 4px;
        border: 2px solid rgba(255,255,255,0.5);
        background: linear-gradient(
            135deg,
            rgba(255,255,255,0.25) 0%,
            rgba(255,255,255,0.1) 20%,
            transparent 50%,
            rgba(255,255,255,0.05) 85%,
            rgba(255,255,255,0.15) 100%
        );
        box-shadow: 
            inset 0 0 20px rgba(255,255,255,0.15),
            0 0 25px rgba(196,30,58,0.4);
        pointer-events: none;
    }
    
    /* 玻璃正面高光条 */
    .glass-face-front::after {
        content: '';
        position: absolute;
        top: 8%;
        left: 5%;
        width: 70%;
        height: 2px;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
        filter: blur(1px);
        transform: rotate(-12deg);
        border-radius: 2px;
    }
    
    /* 玻璃背面 - 透明玻璃层 */
    .glass-face-back {
        position: absolute;
        width: 100%;
        height: 100%;
        transform: translateZ(-10px) rotateY(180deg);
        border-radius: 4px;
        border: 2px solid rgba(255,255,255,0.5);
        background: linear-gradient(
            -135deg,
            rgba(255,255,255,0.25) 0%,
            rgba(255,255,255,0.1) 20%,
            transparent 50%,
            rgba(255,255,255,0.05) 85%,
            rgba(255,255,255,0.15) 100%
        );
        box-shadow: 
            inset 0 0 20px rgba(255,255,255,0.15),
            0 0 25px rgba(196,30,58,0.4);
        pointer-events: none;
    }
    
    /* 玻璃侧面 - 厚度边缘 */
    .glass-edge {
        position: absolute;
        background: linear-gradient(
            180deg,
            rgba(255,255,255,0.5) 0%,
            rgba(200,220,255,0.4) 20%,
            rgba(150,180,200,0.3) 50%,
            rgba(100,130,150,0.4) 80%,
            rgba(255,255,255,0.3) 100%
        );
        transform-style: preserve-3d;
    }
    
    .glass-edge-top {
        width: 100%;
        height: 20px;
        top: -10px;
        left: 0;
        transform: rotateX(-90deg);
        transform-origin: bottom center;
    }
    
    .glass-edge-bottom {
        width: 100%;
        height: 20px;
        bottom: -10px;
        left: 0;
        transform: rotateX(90deg);
        transform-origin: top center;
    }
    
    .glass-edge-left {
        width: 20px;
        height: 100%;
        top: 0;
        left: -10px;
        transform: rotateY(90deg);
        transform-origin: right center;
        background: linear-gradient(
            90deg,
            rgba(255,255,255,0.6) 0%,
            rgba(200,220,255,0.4) 50%,
            rgba(150,180,200,0.3) 100%
        );
    }
    
    .glass-edge-right {
        width: 20px;
        height: 100%;
        top: 0;
        right: -10px;
        transform: rotateY(-90deg);
        transform-origin: left center;
        background: linear-gradient(
            90deg,
            rgba(150,180,200,0.3) 0%,
            rgba(200,220,255,0.4) 50%,
            rgba(255,255,255,0.6) 100%
        );
    }
    
    /* 玻璃边框发光 */
    .glass-glow {
        position: absolute;
        inset: -5px;
        border-radius: 8px;
        background: transparent;
        box-shadow: 
            0 0 25px rgba(255,255,255,0.4),
            0 0 50px rgba(196,30,58,0.3),
            inset 0 0 25px rgba(255,255,255,0.15);
        z-index: -1;
    }
    
    .glass-shard.featured {
        z-index: 1000 !important;
    }
    
    .glass-shard.featured .glass-glow {
        box-shadow: 
            0 0 40px rgba(255,255,255,0.6),
            0 0 80px rgba(196,30,58,0.5),
            inset 0 0 30px rgba(255,255,255,0.2);
    }
    
    .glass-shard.featured .glass-face-front {
        box-shadow: 
            inset 0 0 40px rgba(255,255,255,0.2),
            0 0 40px rgba(196,30,58,0.5);
    }
    
    .glass-crack-overlay {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 100;
        opacity: 0;
        animation: glassCrackAppear 0.3s ease forwards;
    }
    
    .crack-line {
        position: absolute;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.9), transparent);
        height: 2px;
        transform-origin: center;
        box-shadow: 0 0 10px rgba(255,255,255,0.8), 0 0 20px rgba(196,30,58,0.5);
    }
    
    .glass-particle {
        position: absolute;
        background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(200,220,255,0.7));
        border-radius: 1px;
        box-shadow: 0 0 8px rgba(255,255,255,0.6), 0 0 15px rgba(196,30,58,0.3);
    }
    
    .glass-ambient-light {
        position: absolute;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(196,30,58,0.3) 0%, transparent 70%);
        filter: blur(30px);
        animation: glassAmbientPulse 3s ease-in-out infinite;
    }
    
    @keyframes glassCarouselRotate {
        0% { transform: rotateY(0deg) rotateX(5deg); }
        100% { transform: rotateY(360deg) rotateX(5deg); }
    }
    
    @keyframes glassShardFloat {
        0%, 100% { 
            transform: translate(-50%, -50%) 
                       rotateX(var(--rx)) rotateY(var(--ry)) rotateZ(var(--rz))
                       translateZ(var(--tz));
        }
        50% { 
            transform: translate(-50%, -50%) 
                       rotateX(calc(var(--rx) + 10deg)) rotateY(calc(var(--ry) + 15deg)) rotateZ(calc(var(--rz) + 5deg))
                       translateZ(calc(var(--tz) + 30px));
        }
    }
    
    .glass-crack-overlay {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 100;
        opacity: 0;
        animation: glassCrackAppear 0.3s ease forwards;
    }
    
    .crack-line {
        position: absolute;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.9), transparent);
        height: 2px;
        transform-origin: center;
        box-shadow: 0 0 10px rgba(255,255,255,0.8), 0 0 20px rgba(196,30,58,0.5);
    }
    
    .glass-particle {
        position: absolute;
        background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(200,220,255,0.7));
        border-radius: 1px;
        box-shadow: 0 0 8px rgba(255,255,255,0.6), 0 0 15px rgba(196,30,58,0.3);
    }
    
    .glass-ambient-light {
        position: absolute;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(196,30,58,0.3) 0%, transparent 70%);
        filter: blur(30px);
        animation: glassAmbientPulse 3s ease-in-out infinite;
    }
    
    @keyframes glassCarouselRotate {
        0% { transform: rotateY(0deg) rotateX(5deg); }
        100% { transform: rotateY(360deg) rotateX(5deg); }
    }
    
    @keyframes glassShine {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }
    
    @keyframes glassShardFloat {
        0%, 100% { 
            transform: translate(-50%, -50%) 
                       rotateX(var(--rx)) rotateY(var(--ry)) rotateZ(var(--rz))
                       translateZ(var(--tz));
        }
        50% { 
            transform: translate(-50%, -50%) 
                       rotateX(calc(var(--rx) + 10deg)) rotateY(calc(var(--ry) + 15deg)) rotateZ(calc(var(--rz) + 5deg))
                       translateZ(calc(var(--tz) + 30px));
        }
    }
    
    @keyframes glassShardFloatSmooth {
        0%, 100% { 
            transform: translate(-50%, -50%) 
                       translateX(var(--final-x)) translateY(var(--final-y)) translateZ(var(--final-z))
                       rotateX(var(--final-rx)) rotateY(var(--final-ry)) rotateZ(var(--final-rz))
                       scale(1);
            opacity: 1;
        }
        33% {
            transform: translate(-50%, -50%) 
                       translateX(var(--final-x)) translateY(calc(var(--final-y) - 35px)) translateZ(calc(var(--final-z) + 50px))
                       rotateX(calc(var(--final-rx) + 10deg)) rotateY(calc(var(--final-ry) + 18deg)) rotateZ(calc(var(--final-rz) + 5deg))
                       scale(1);
            opacity: 1;
        }
        66% { 
            transform: translate(-50%, -50%) 
                       translateX(var(--final-x)) translateY(calc(var(--final-y) + 30px)) translateZ(calc(var(--final-z) + 25px))
                       rotateX(calc(var(--final-rx) - 8deg)) rotateY(calc(var(--final-ry) + 35deg)) rotateZ(calc(var(--final-rz) - 6deg))
                       scale(1);
            opacity: 1;
        }
    }
    
    @keyframes glassFeature {
        0%, 100% { filter: brightness(1) contrast(1.1); }
        50% { filter: brightness(1.4) contrast(1.2); }
    }
    
    @keyframes glassCrackAppear {
        0% { opacity: 0; }
        50% { opacity: 1; }
        100% { opacity: 0; }
    }
    
    @keyframes glassExplode {
        0% { 
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }
        100% { 
            transform: translate(calc(-50% + var(--ex)), calc(-50% + var(--ey))) 
                       rotateX(var(--erx)) rotateY(var(--ery)) rotateZ(var(--erz))
                       translateZ(var(--ez)) scale(0.8);
            opacity: 1;
        }
    }
    
    @keyframes glassAmbientPulse {
        0%, 100% { opacity: 0.5; transform: scale(1); }
        50% { opacity: 0.8; transform: scale(1.2); }
    }
    
    @keyframes glassParticleFly {
        0% { 
            transform: translate(0, 0) rotate(0deg);
            opacity: 1;
        }
        100% { 
            transform: translate(var(--px), var(--py)) rotate(var(--pr));
            opacity: 0;
        }
    }
</style>
<script>
// ==================== 数据配置 ====================
const imageSeries = {
    1: ['图片/莉莉丝1.png', '图片/莉莉丝1-1.png'],
    2: ['图片/莉莉丝2.png', '图片/莉莉丝2-1.png', '图片/莉莉丝2-2.png', '图片/莉莉丝2-3.png', '图片/莉莉丝2-4.png'],
    3: ['图片/莉莉丝3.png'],
    4: ['图片/莉莉丝4.png', '图片/莉莉丝4-1.png', '图片/莉莉丝4-2.png', '图片/莉莉丝4-3.png', '图片/莉莉丝4-4.png'],
    5: ['图片/莉莉丝5.png', '图片/莉莉丝5-1.png', '图片/莉莉丝5-2.png', '图片/莉莉丝5-3.png'],
    6: ['图片/莉莉丝6.png', '图片/莉莉丝6-1.png', '图片/莉莉丝6-2.png', '图片/莉莉丝6-3.png'],
    7: ['图片/莉莉丝7.png'],
    8: ['图片/莉莉丝8.png', '图片/莉莉丝8-1.png', '图片/莉莉丝8-2.png', '图片/莉莉丝8-3.png', '图片/莉莉丝8-4.png', '图片/莉莉丝8-5.png', '图片/莉莉丝8-6.png'],
    9: ['图片/莉莉9.png', '图片/莉莉丝9-1.png', '图片/莉莉丝9-2.png'],
    10: ['图片/莉莉丝10.png', '图片/莉莉丝10-1.png', '图片/莉莉丝10-2.png', '图片/莉莉丝10-3.png', '图片/莉莉丝10-4.png', '图片/莉莉丝10-5.png'],
    11: ['图片/莉莉丝11.png', '图片/莉莉丝11-1.png', '图片/莉莉丝11-2.png', '图片/莉莉丝11-3.png'],
    12: ['图片/莉莉丝12.png', '图片/莉莉丝12-1.png', '图片/莉莉丝12-2.png', '图片/莉莉丝12-3.png'],
    13: ['图片/莉莉丝13.png', '图片/莉莉丝13-1.png', '图片/莉莉丝13-2.png', '图片/莉莉丝13-3.png', '图片/莉莉丝13-4.png', '图片/莉莉丝13-5.png', '图片/莉莉丝13-6.png'],
    14: ['图片/莉莉丝14.png', '图片/莉莉丝14-1.png'],
    15: ['图片/莉莉丝15.png', '图片/莉莉丝15-1.png'],
    16: ['图片/莉莉丝16.png', '图片/莉莉丝16-1.png'],
    17: ['图片/莉莉丝17.png', '图片/莉莉丝17-1.png'],
    18: ['图片/莉莉丝18.png', '图片/莉莉丝18-1.png'],
    19: ['图片/莉莉丝19.png'],
    20: ['图片/莉莉丝20.png', '图片/莉莉丝20-1.png', '图片/莉莉丝20-2.png'],
    21: ['图片/莉莉丝21.png', '图片/莉莉丝21-1.png'],
    22: ['图片/莉莉丝22.png', '图片/莉莉丝22-1.png'],
    23: ['图片/莉莉丝23.png', '图片/莉莉丝23-1.png'],
    24: ['图片/莉莉丝24.png', '图片/莉莉丝24-1.png', '图片/莉莉丝24-2.png', '图片/莉莉丝24-3.png']
};

const allImages = Object.values(imageSeries).flat();
const seriesKeys = Object.keys(imageSeries).map(Number);
const firstImagesOnly = seriesKeys.map(key => imageSeries[key][0]); // 每个系列的第一张图片

// 为场景1创建扩展图片列表
// 8秒 ÷ 0.25秒 = 32张图片
// 顺序：莉莉丝1~23的第一张 → 补充8张第二张图片 → 莉莉丝24作为最后一张

// 创建补充图片池：从每个系列中取第二张图片（如果有的话）
const supplementImages = [];
seriesKeys.forEach(key => {
    const series = imageSeries[key];
    if (series.length > 1) {
        supplementImages.push(series[1]); // 取第二张图片
    }
});

// 构建场景1图片列表
const scene1Images = [];
// 第1-23张：莉莉丝1~23的第一张图片
for (let i = 0; i < 23; i++) {
    scene1Images.push(firstImagesOnly[i]);
}
// 第24-31张：补充8张第二张图片
for (let i = 0; i < 8 && i < supplementImages.length; i++) {
    scene1Images.push(supplementImages[i]);
}
// 第32张：莉莉丝24作为最后一张
scene1Images.push(firstImagesOnly[23]);

// 预加载场景1的所有图片到内存缓存
const scene1ImageCache = [];
scene1Images.forEach(src => {
    const img = new Image();
    img.src = src;
    scene1ImageCache.push(img);
});

const lyrics = [
    { time: 200, cn: '啊-', jp: 'あ-', animIn: 'blur', pvAnim: null },
    { time: 20590, cn: '坠入深邃黑暗的深渊，沉沉睡去', jp: '深い闇の底 眠りに堕ちて', animIn: 'typewriter', pvAnim: 'lyric1', pvPos: 'custom' },
    { time: 26170, cn: '来到谁的声音都无法抵达之处', jp: '誰の声も届かない場所', animIn: 'wave', pvAnim: 'lyric2', pvPos: 'custom' },
    { time: 31280, cn: '是梦是现实？连呼吸都冻结', jp: '夢か現か 息も凍える', animIn: 'glitch', pvAnim: 'lyric3', pvPos: 'custom' },
    { time: 36540, cn: '影子为我赋予了名字', jp: '影が私を名付けた', animIn: 'blur', pvAnim: 'lyric4', pvPos: 'custom' },
    { time: 41730, cn: '在耳畔低语：', jp: '耳元で囁く', animIn: '3d', pvAnim: 'lyric5', pvPos: 'custom' },
    { time: 46520, cn: '"你即是我，我即是你"', jp: '「君は私 私は君」', animIn: 'scatter', pvAnim: 'lyric6', pvPos: 'custom' },
    { time: 52200, cn: '如同绽放在虚空中的花朵', jp: '虚空に咲く花のように', animIn: 'wave', pvAnim: 'lyric7', pvPos: 'custom' },
    { time: 57130, cn: '背负着毁灭之命起舞', jp: '滅びを背負いながら踊る', animIn: 'blur', pvAnim: 'lyric8', pvPos: 'custom' },
    { time: 62390, cn: '这份痛楚将化作利剑', jp: 'この痛みは剣に変わる', animIn: 'glitch', pvAnim: 'lyric9', pvPos: 'custom' },
    { time: 67260, cn: '以Tulpa之名，撕裂这世界！', jp: 'Tulpaの名で 世界を切り裂け', animIn: 'scatter', pvAnim: 'lyric10', pvPos: 'custom' }
];

const sceneTimeline = [
    { time: 0, type: 'mirror-sequence', series: 'scene1-extended', transition: 'none' },
    { time: 8000, type: 'intro', transition: 'strips-v' },
    { time: 16000, type: 'glass-shatter', series: 2, transition: 'none' },
    { time: 20000, type: 'single-dramatic', series: 3, transition: 'breath-settle' },
    { time: 26000, type: 'expression-loop', series: 4, transition: 'flash' },
    { time: 31000, type: 'split-morph', series: 5, transition: 'strips-h' },
    { time: 36000, type: 'quad-grid', series: 6, transition: 'glitch' },
    { time: 41000, type: 'whisper-float', series: 7, transition: 'radial' },
    { time: 46000, type: 'tulpa-duality', series: 8, transition: 'cyan-glitch' },
    { time: 52000, type: 'rapid-sequence', series: 9, transition: 'strips-h' },
    { time: 57000, type: 'dance-montage', series: 10, transition: 'strips-v' },
    { time: 62000, type: 'world-tear-finale', series: [11, 12, 13], transition: 'radial-strips' },
    { time: 67000, type: 'scene13-placeholder', series: [14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24], transition: 'diagonal-strips' }
];

const PV_END_TIME = 72000;

// DOM
const sceneContainer = document.getElementById('sceneContainer');
const lyricCn = document.getElementById('lyricCn');
const lyricJp = document.getElementById('lyricJp');
const lyricsContainer = document.getElementById('lyricsContainer');
const bgMusic = document.getElementById('bgMusic');
const playBtn = document.getElementById('playBtn');
const playIcon = document.getElementById('playIcon');
const pauseIcon = document.getElementById('pauseIcon');
const progressFill = document.getElementById('progressFill');
const progressContainer = document.getElementById('progressContainer');
const timeDisplay = document.getElementById('timeDisplay');
const transitionSystem = document.getElementById('transitionSystem');
const loadingScreen = document.getElementById('loadingScreen');
const loadingFill = document.getElementById('loadingFill');
const albumMode = document.getElementById('albumMode');
const albumBook = document.getElementById('albumBook');
const bookCover = document.getElementById('bookCover');
const lastPage = document.getElementById('lastPage');
const flippablePages = document.getElementById('flippablePages');
const albumNav = document.getElementById('albumNav');
const pageIndicator = document.getElementById('pageIndicator');
const viewer = document.getElementById('viewer');
const viewerImage = document.getElementById('viewerImage');
const viewerLabel = document.getElementById('viewerLabel');
const viewerDots = document.getElementById('viewerDots');
const viewerHint = document.getElementById('viewerHint');

let isPlaying = false;
let currentSceneIndex = -1;
let currentLyricIndex = -1;
let sequenceIntervals = [];
let isAlbumMode = false;

// ==================== 相册状态变量 ====================
/**
 * currentPageIndex - 当前页码索引
 * - 0: 显示 A反面 + B1正面（图1-4在右侧）
 * - 1: 显示 B1反面 + B2正面（图5-8在左侧，图9-12在右侧）
 * - 2: 显示 B2反面 + B3正面（图13-16在左侧，图17-20在右侧）
 * - 3: 显示 B3反面 + 封底（图21-24在左侧）
 */
let currentPageIndex = 0;

/**
 * totalInnerPages - 内页总数（B1, B2, B3...）
 * 计算方式：总图片数 ÷ 8（每个内页正反面各4张）
 * 24张图 ÷ 8 = 3个内页
 */
let totalInnerPages = 0;

/**
 * currentViewerSeries - 当前在查看器中显示的图片系列
 * 是一个图片路径数组，包含该系列的所有表情变体
 */
let currentViewerSeries = null;

/**
 * currentViewerIndex - 当前在查看器中显示的图片索引
 * 用于在同一系列的多张图片间切换
 */
let currentViewerIndex = 0;

/**
 * isPageTurning - 是否正在翻页中
 * 用于防止翻页动画过程中的重复点击
 */
let isPageTurning = false;

/**
 * isCoverOpen - 封面是否已打开
 * true: 相册已展开，可以浏览内页
 * false: 相册关闭，只显示封面
 */
let isCoverOpen = false;

/**
 * PHOTOS_PER_PAGE - 每个页面（单面）的图片数量
 * 固定为4张，2x2网格布局
 */
const PHOTOS_PER_PAGE = 4;

const imgEnterAnims = ['imgSlideLeft', 'imgSlideRight', 'imgSlideUp', 'imgZoomIn', 'imgZoomOut', 'imgFlipX', 'imgCircleReveal', 'imgDiagonalReveal', 'imgGlitchIn', 'imgBounceIn', 'imgSwingIn'];
const imgShowAnims = ['imgFloat', 'imgPulse', 'imgKenBurns', 'imgSway', 'imgBreath'];

function randomFrom(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
</script>
<script>
// ==================== 预加载 ====================
function preloadImages() {
    let loaded = 0;
    allImages.forEach(src => {
        const img = new Image();
        img.onload = img.onerror = () => {
            loaded++;
            loadingFill.style.width = (loaded / allImages.length * 100) + '%';
            if (loaded >= allImages.length) setTimeout(() => loadingScreen.classList.add('hidden'), 500);
        };
        img.src = src;
    });
}

// ==================== 转场 ====================
function playTransition(type) {
    transitionSystem.innerHTML = '';
    if (type === 'none') return;
    switch(type) {
        case 'strips-v':
            for (let i = 0; i < 8; i++) {
                const strip = document.createElement('div');
                strip.className = 'mask-strip';
                strip.style.cssText = `left:${i*12.5}%;top:0;width:12.5%;height:100%;transform:scaleX(0);transform-origin:${i%2?'right':'left'};animation:stripExpand 0.3s ease ${i*0.04}s forwards,stripContract 0.3s ease ${0.35+i*0.04}s forwards;`;
                transitionSystem.appendChild(strip);
            }
            break;
        case 'strips-h':
            for (let i = 0; i < 6; i++) {
                const strip = document.createElement('div');
                strip.className = 'mask-strip';
                strip.style.cssText = `top:${i*16.67}%;left:0;height:16.67%;width:100%;transform:scaleY(0);transform-origin:${i%2?'bottom':'top'};animation:stripExpandY 0.3s ease ${i*0.05}s forwards,stripContractY 0.3s ease ${0.35+i*0.05}s forwards;`;
                transitionSystem.appendChild(strip);
            }
            break;
        case 'flash':
            transitionSystem.innerHTML = '<div style="position:absolute;inset:0;background:#fff;animation:finalFlash 0.4s ease forwards;"></div>';
            break;
        case 'glitch':
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const bar = document.createElement('div');
                    bar.style.cssText = `position:absolute;left:0;width:100%;height:${5+Math.random()*25}px;top:${Math.random()*100}%;background:${Math.random()>0.5?'#c41e3a':'#fff'};opacity:0.8;`;
                    transitionSystem.appendChild(bar);
                    setTimeout(() => bar.remove(), 100);
                }, i * 50);
            }
            break;
        case 'cyan-glitch':
            // 青蓝色故障转场 - 适合淡青蓝色调图片
            let glitchHTML = '';
            // 青蓝色闪光
            glitchHTML += '<div style="position:absolute;inset:0;background:rgba(88,166,196,0.6);animation:finalFlash 0.3s ease forwards;"></div>';
            // RGB分离条
            for (let i = 0; i < 4; i++) {
                const top = 15 + i * 22;
                glitchHTML += `<div style="position:absolute;top:${top}%;left:0;width:100%;height:8%;background:linear-gradient(90deg,rgba(0,255,255,0.5),transparent 30%,transparent 70%,rgba(255,100,150,0.5));animation:cyanGlitchSlide 0.4s ease ${i*0.05}s forwards;"></div>`;
            }
            // 扫描线
            glitchHTML += '<div style="position:absolute;inset:0;background:repeating-linear-gradient(0deg,transparent 0px,transparent 3px,rgba(88,166,196,0.1) 3px,rgba(88,166,196,0.1) 6px);animation:finalFlash 0.5s ease forwards;"></div>';
            transitionSystem.innerHTML = glitchHTML;
            break;
        case 'radial-strips':
            // 环状扩散条纹遮罩（红色，与strips-v/strips-h一致）
            let radialHTML = '<div style="position:absolute;inset:0;display:flex;justify-content:center;align-items:center;">';
            // 8个环状条纹从中心向外扩散
            for (let i = 0; i < 8; i++) {
                const size = 15 + i * 15; // 环的大小递增
                const delay = i * 0.04;
                radialHTML += `<div style="position:absolute;width:${size}vmax;height:${size}vmax;border:${8-i}vmax solid #c41e3a;border-radius:50%;transform:scale(0);animation:radialStripExpand 0.35s ease ${delay}s forwards, radialStripContract 0.3s ease ${0.4+delay}s forwards;"></div>`;
            }
            radialHTML += '</div>';
            transitionSystem.innerHTML = radialHTML;
            break;
        case 'diagonal-strips':
            // 对角斜向条纹遮罩（红色，从左上到右下）
            let diagonalHTML = '<div style="position:absolute;inset:0;overflow:hidden;">';
            for (let i = 0; i < 10; i++) {
                const offset = -20 + i * 20; // 从-20%开始，每条间隔20%
                diagonalHTML += `
                    <div style="
                        position:absolute;
                        left:${offset}%;
                        top:-20%;
                        width:15%;
                        height:150%;
                        background:#c41e3a;
                        transform:rotate(45deg) scaleY(0);
                        transform-origin:center top;
                        animation:diagonalStripExpand 0.3s ease ${i*0.04}s forwards, diagonalStripContract 0.3s ease ${0.4+i*0.04}s forwards;
                    "></div>
                `;
            }
            diagonalHTML += '</div>';
            transitionSystem.innerHTML = diagonalHTML;
            break;
        case 'breath-settle':
            // 呼吸沉淀转场 - 从暗红激昂过渡到冷蓝舒缓
            // 设计理念：红色能量向中心收缩，然后蓝色宁静从中心绽放
            let breathHTML = '<div style="position:absolute;inset:0;overflow:hidden;">';
            
            // 第一阶段：红色能量向中心收缩（暗红色的余韵）
            breathHTML += `
                <div style="position:absolute;inset:0;background:radial-gradient(circle at center, transparent 0%, rgba(139,0,0,0.8) 30%, rgba(196,30,58,0.9) 100%);animation:breathRedContract 0.5s ease-out forwards;"></div>
            `;
            
            // 红色粒子向中心汇聚
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const startX = 50 + Math.cos(angle) * 60;
                const startY = 50 + Math.sin(angle) * 60;
                breathHTML += `
                    <div style="
                        position:absolute;
                        left:${startX}%;
                        top:${startY}%;
                        width:8px;
                        height:8px;
                        background:radial-gradient(circle, #c41e3a 0%, transparent 70%);
                        border-radius:50%;
                        animation:breathParticleIn 0.4s ease-out ${i*0.02}s forwards;
                    "></div>
                `;
            }
            
            // 第二阶段：中心白光闪烁（转折点）
            breathHTML += `
                <div style="position:absolute;top:50%;left:50%;width:0;height:0;background:radial-gradient(circle, rgba(255,255,255,0.95) 0%, rgba(200,220,255,0.6) 40%, transparent 70%);border-radius:50%;transform:translate(-50%,-50%);animation:breathCenterFlash 0.6s ease 0.35s forwards;"></div>
            `;
            
            // 第三阶段：蓝色宁静从中心向外扩散
            breathHTML += `
                <div style="position:absolute;inset:0;background:radial-gradient(circle at center, rgba(85,136,204,0.7) 0%, rgba(51,68,102,0.5) 40%, transparent 70%);opacity:0;animation:breathBlueExpand 0.6s ease 0.5s forwards;"></div>
            `;
            
            // 蓝色涟漪扩散（两层）
            breathHTML += `
                <div style="position:absolute;top:50%;left:50%;width:50px;height:50px;border:2px solid rgba(85,136,204,0.6);border-radius:50%;transform:translate(-50%,-50%) scale(0);animation:breathRipple 0.8s ease 0.55s forwards;"></div>
                <div style="position:absolute;top:50%;left:50%;width:50px;height:50px;border:1px solid rgba(85,136,204,0.4);border-radius:50%;transform:translate(-50%,-50%) scale(0);animation:breathRipple 0.8s ease 0.65s forwards;"></div>
            `;
            
            breathHTML += '</div>';
            transitionSystem.innerHTML = breathHTML;
            break;
        default:
            transitionSystem.innerHTML = '<div style="position:absolute;inset:0;background:#c41e3a;animation:finalFlash 0.5s ease forwards;"></div>';
    }
    setTimeout(() => transitionSystem.innerHTML = '', 1000);
}

// ==================== 歌词 ====================
let currentPvLyricIndex = -1;
let pvLyricTimeout = null;
let pvLyricFadeTimeout = null;

function showPvLyric(lyric) {
    const overlay = document.getElementById('pvLyricOverlay');
    if (!overlay || !lyric.pvAnim) return;
    
    // 清除之前的定时器
    if (pvLyricTimeout) clearTimeout(pvLyricTimeout);
    if (pvLyricFadeTimeout) clearTimeout(pvLyricFadeTimeout);
    
    // 清除之前的歌词和淡出状态
    overlay.classList.remove('pv-lyric-fadeout');
    overlay.innerHTML = '';
    
    // 根据不同歌词调用不同的渲染函数
    switch(lyric.pvAnim) {
        case 'lyric1': renderLyric1(overlay, lyric.cn); break;
        case 'lyric2': renderLyric2(overlay, lyric.cn); break;
        case 'lyric3': renderLyric3(overlay, lyric.cn); break;
        case 'lyric4': renderLyric4(overlay, lyric.cn); break;
        case 'lyric5': renderLyric5(overlay, lyric.cn); break;
        case 'lyric6': renderLyric6(overlay, lyric.cn); break;
        case 'lyric7': renderLyric7(overlay, lyric.cn); break;
        case 'lyric8': renderLyric8(overlay, lyric.cn); break;
        case 'lyric9': renderLyric9(overlay, lyric.cn); break;
        case 'lyric10': renderLyric10(overlay, lyric.cn); break;
    }
    
    // 设置退场动画时间
    // lyric6特殊处理：5.4秒退场
    // lyric10（最后一句）：不自动退场，保持到场景13结束
    if (lyric.pvAnim === 'lyric10') {
        // 不设置退场定时器，歌词保持显示直到场景切换
        return;
    }
    
    const fadeOutDelay = lyric.pvAnim === 'lyric6' ? 5400 : 4500;
    
    pvLyricTimeout = setTimeout(() => {
        overlay.classList.add('pv-lyric-fadeout');
        pvLyricFadeTimeout = setTimeout(() => {
            overlay.innerHTML = '';
            overlay.classList.remove('pv-lyric-fadeout');
        }, 500);
    }, fadeOutDelay);
}

// 歌词1: "坠入深邃黑暗的深渊，沉沉睡去" - 文字从上方坠落，分两行
function renderLyric1(overlay, text) {
    const part1 = '坠入深邃黑暗的深渊，';
    const part2 = '沉沉睡去';
    
    // 蓝色阴影样式（和场景5的lyric2同款，但用蓝色）
    const blueShadow = 'text-shadow: 0 0 30px rgba(85,136,204,0.8), 0 0 60px rgba(85,136,204,0.5), 4px 4px 0 #334466;';
    
    // 第一部分 - 顶部，逐字坠落
    const line1 = document.createElement('div');
    line1.className = 'pv-custom-line';
    line1.style.cssText = 'position:absolute;top:20%;left:50%;transform:translateX(-50%);font-size:3.5rem;' + blueShadow;
    part1.split('').forEach((char, i) => {
        const span = document.createElement('span');
        span.textContent = char;
        span.style.cssText = `display:inline-block;opacity:0;animation:pvFallDown 0.8s cubic-bezier(0.34,1.56,0.64,1) ${i*0.06}s forwards;`;
        line1.appendChild(span);
    });
    overlay.appendChild(line1);
    
    // 第二部分 - 中下方，放大淡入（22.8秒出现，即歌词开始后2.2秒）
    const line2 = document.createElement('div');
    line2.className = 'pv-custom-line';
    line2.style.cssText = 'position:absolute;top:55%;left:50%;transform:translateX(-50%);font-size:5rem;opacity:0;animation:pvZoomFadeIn 1s ease 2.2s forwards;' + blueShadow;
    line2.textContent = part2;
    overlay.appendChild(line2);
    
    // 添加下坠粒子（第一行出现时）
    for(let i=0;i<15;i++){
        const p = document.createElement('div');
        p.className = 'pv-particle-fall';
        p.style.cssText = `left:${20+Math.random()*60}%;animation-delay:${Math.random()*0.5}s;`;
        overlay.appendChild(p);
    }
    
    // "沉沉睡去"出现时添加第二波下坠粒子（延迟2.2秒）
    setTimeout(() => {
        for(let i=0;i<20;i++){
            const p = document.createElement('div');
            p.className = 'pv-particle-fall';
            p.style.cssText = `left:${15+Math.random()*70}%;animation-delay:${Math.random()*0.8}s;animation-duration:${1.2+Math.random()*0.8}s;`;
            overlay.appendChild(p);
        }
    }, 2200);
}

// 歌词2: "来到谁的声音都无法抵达之处" - 文字从四周向中心汇聚
function renderLyric2(overlay, text) {
    const segments = ['来到', '谁的声音', '都无法', '抵达之处'];
    
    const setupLyrics = () => {
        const camera = document.getElementById('scene5Camera');
        if (!camera) {
            setTimeout(setupLyrics, 50);
            return;
        }
        
        // 手动指定词段位置和大小
        // x: 左右位置（50是正中间）
        // y: 上下位置（50是正中间）
        // size: 字体大小（rem），需要补偿摄像机scale的放大效果
        const segmentPositions = [
            { x: 30, y: 65, size: 2.8 },   // 第1个词段：来到
            { x: 42, y: 55, size: 2.4 },   // 第2个词段：谁的声音
            { x: 52, y: 40, size: 2.0 },   // 第3个词段：都无法
            { x: 41, y: 19, size: 1.6 }    // 第4个词段：抵达之处
        ];
        
        // 词段出现的时间点（毫秒）
        const appearTimes = [0, 1200, 2500, 3500];
        
        segments.forEach((seg, i) => {
            const container = document.createElement('div');
            container.style.cssText = `position:absolute;left:${segmentPositions[i].x}%;top:${segmentPositions[i].y}%;transform:translate(-50%,-50%);opacity:0;pointer-events:none;z-index:100;`;
            
            const div = document.createElement('div');
            div.className = 'pv-custom-line';
            div.style.cssText = `font-size:${segmentPositions[i].size}rem;white-space:nowrap;text-shadow:0 0 20px rgba(196,30,58,0.8),0 0 40px rgba(196,30,58,0.5),3px 3px 0 #000;`;
            div.textContent = seg;
            container.appendChild(div);
            
            const rippleContainer = document.createElement('div');
            rippleContainer.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);pointer-events:none;';
            container.appendChild(rippleContainer);
            
            camera.appendChild(container);
            
            setTimeout(() => {
                container.style.transition = 'opacity 0.5s ease';
                container.style.opacity = '1';
                
                for (let r = 0; r < 3; r++) {
                    setTimeout(() => {
                        const ripple = document.createElement('div');
                        ripple.style.cssText = `
                            position:absolute;top:50%;left:50%;
                            width:20px;height:20px;
                            border:2px solid rgba(196,30,58,0.8);
                            border-radius:50%;
                            transform:translate(-50%,-50%) scale(1);
                            opacity:1;
                            animation:lyric2Ripple 1.2s ease-out forwards;
                        `;
                        rippleContainer.appendChild(ripple);
                        setTimeout(() => ripple.remove(), 1200);
                    }, r * 200);
                }
            }, appearTimes[i]);
        });
    };
    
    setupLyrics();
    
    if (!document.getElementById('lyric2RippleStyle')) {
        const style = document.createElement('style');
        style.id = 'lyric2RippleStyle';
        style.textContent = `
            @keyframes lyric2Ripple {
                0% { transform: translate(-50%,-50%) scale(1); opacity: 0.8; }
                100% { transform: translate(-50%,-50%) scale(8); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
    }
}

// 歌词3: "是梦是现实？连呼吸都冻结" - 故障分裂效果
function renderLyric3(overlay, text) {
    const part1 = '是梦是现实？';
    const part2 = '连呼吸都冻结';
    
    // 歌词开始时间是31280ms，"连呼吸都冻结"在33000ms显示，延迟1720ms
    const part2Delay = 1720;
    
    // 创建竖向逐字显示的文字（带多层阴影效果）
    const createVerticalText = (textContent, side, startDelay) => {
        const container = document.createElement('div');
        container.style.cssText = `position:absolute;top:50%;${side}:10%;transform:translateY(-50%);`;
        
        // 为每个字创建容器
        textContent.split('').forEach((char, charIndex) => {
            const charContainer = document.createElement('div');
            charContainer.style.cssText = `position:relative;display:block;margin-bottom:0.3em;`;
            
            // 创建多层影子（蓝色色系）
            for(let i=3;i>=0;i--){
                const shadow = document.createElement('span');
                shadow.className = 'pv-custom-line';
                const offset = i * 5;
                const opacity = i === 0 ? 1 : 0.3 - i * 0.08;
                const blur = i * 2;
                const charDelay = startDelay + charIndex * 120; // 每个字间隔120ms
                // 蓝色系text-shadow泛光
                const blueShadow = 'text-shadow: 0 0 30px rgba(58,130,196,0.8), 0 0 60px rgba(58,130,196,0.5), 4px 4px 0 #1a3a5c;';
                shadow.style.cssText = `position:${i===0?'relative':'absolute'};top:${i===0?0:offset}px;left:${i===0?0:offset}px;font-size:4.2rem;writing-mode:vertical-rl;text-orientation:upright;opacity:0;color:${i===0?'#fff':'#1a3a5c'};filter:blur(${blur}px);animation:pvCharGlitchIn 0.4s ease ${charDelay + i*50}ms forwards;--final-opacity:${opacity};display:inline-block;${i===0?blueShadow:''}`;
                shadow.textContent = char;
                charContainer.appendChild(shadow);
            }
            
            // 添加色相故障分离效果（红蓝偏移）
            const redGhost = document.createElement('span');
            redGhost.style.cssText = `position:absolute;top:-3px;left:-4px;font-size:4.2rem;writing-mode:vertical-rl;text-orientation:upright;color:rgba(255,0,0,0.5);opacity:0;animation:pvCharGlitchIn 0.4s ease ${startDelay + charIndex * 120}ms forwards, pvGlitchShake 0.1s ease infinite;--final-opacity:0.3;mix-blend-mode:screen;`;
            redGhost.textContent = char;
            charContainer.appendChild(redGhost);
            
            const blueGhost = document.createElement('span');
            blueGhost.style.cssText = `position:absolute;top:3px;left:4px;font-size:4.2rem;writing-mode:vertical-rl;text-orientation:upright;color:rgba(0,255,255,0.5);opacity:0;animation:pvCharGlitchIn 0.4s ease ${startDelay + charIndex * 120}ms forwards, pvGlitchShake 0.1s ease infinite reverse;--final-opacity:0.3;mix-blend-mode:screen;`;
            blueGhost.textContent = char;
            charContainer.appendChild(blueGhost);
            
            container.appendChild(charContainer);
        });
        
        return container;
    };
    
    // 左侧文字 - "是梦是现实？"（立即开始）
    const leftText = createVerticalText(part1, 'left', 0);
    overlay.appendChild(leftText);
    
    // 右侧文字 - "连呼吸都冻结"（延迟1720ms，即33秒时显示）
    const rightText = createVerticalText(part2, 'right', part2Delay);
    overlay.appendChild(rightText);
    
    // 故障扫描线
    for(let i=0;i<8;i++){
        const scanLine = document.createElement('div');
        scanLine.style.cssText = `position:absolute;left:0;width:100%;height:2px;background:rgba(255,255,255,0.3);top:${10+i*11}%;animation:pvScanLine 3s linear ${i*0.2}s infinite;pointer-events:none;`;
        overlay.appendChild(scanLine);
    }
    
    // 暗角效果
    const vignette = document.createElement('div');
    vignette.style.cssText = 'position:absolute;inset:0;background:radial-gradient(ellipse at center,transparent 30%,rgba(0,0,0,0.6) 100%);animation:pvFadeIn 0.5s ease forwards;pointer-events:none;';
    overlay.appendChild(vignette);
    
    // 添加故障动画样式
    if (!document.getElementById('lyric3GlitchStyle')) {
        const style = document.createElement('style');
        style.id = 'lyric3GlitchStyle';
        style.textContent = `
            @keyframes pvCharGlitchIn {
                0% { opacity: 0; transform: translateY(-20px) skewX(20deg); }
                50% { opacity: var(--final-opacity); transform: translateY(5px) skewX(-10deg); }
                100% { opacity: var(--final-opacity); transform: translateY(0) skewX(0); }
            }
            @keyframes pvGlitchShake {
                0%, 100% { transform: translate(0, 0); }
                25% { transform: translate(-1px, 1px); }
                50% { transform: translate(1px, -1px); }
                75% { transform: translate(-1px, -1px); }
            }
            @keyframes pvScanLine {
                0% { opacity: 0; top: -5%; }
                10% { opacity: 0.5; }
                90% { opacity: 0.5; }
                100% { opacity: 0; top: 105%; }
            }
        `;
        document.head.appendChild(style);
    }
}

// 歌词4: "影子为我赋予了名字" - 影子效果，文字有多层阴影
function renderLyric4(overlay, text) {
    // 创建多层影子
    for(let i=3;i>=0;i--){
        const shadow = document.createElement('div');
        shadow.className = 'pv-custom-line';
        const offset = i * 8;
        const opacity = i === 0 ? 1 : 0.3 - i * 0.08;
        const blur = i * 3;
        shadow.style.cssText = `position:absolute;top:calc(50% + ${offset}px);left:calc(50% + ${offset}px);transform:translate(-50%,-50%);font-size:3.8rem;opacity:0;color:${i===0?'#fff':'#000'};filter:blur(${blur}px);animation:pvShadowIn 1s ease ${i*0.1}s forwards;--final-opacity:${opacity};`;
        shadow.textContent = text;
        overlay.appendChild(shadow);
    }
    
    // 暗角效果
    const vignette = document.createElement('div');
    vignette.style.cssText = 'position:absolute;inset:0;background:radial-gradient(ellipse at center,transparent 30%,rgba(0,0,0,0.6) 100%);animation:pvFadeIn 0.5s ease forwards;';
    overlay.appendChild(vignette);
}

// 歌词5: "在耳畔低语：" - 从左侧滑入，带蓝色波纹效果
function renderLyric5(overlay, text) {
    const container = document.createElement('div');
    container.className = 'pv-custom-line';
    // 改为左侧显示，蓝色阴影
    const blueShadow = 'text-shadow: 0 0 30px rgba(58,130,196,0.8), 0 0 60px rgba(58,130,196,0.5), 4px 4px 0 #1a3a5c;';
    container.style.cssText = `position:absolute;top:50%;left:10%;transform:translateY(-50%);font-size:4.5rem;text-align:left;${blueShadow}`;
    
    // 波纹容器
    const waveContainer = document.createElement('div');
    waveContainer.style.cssText = 'position:absolute;top:50%;left:10%;transform:translateY(-50%);pointer-events:none;';
    overlay.appendChild(waveContainer);
    
    text.split('').forEach((char, i) => {
        const span = document.createElement('span');
        span.textContent = char;
        // 从左侧滑入
        span.style.cssText = `display:inline-block;opacity:0;transform:translateX(-100px);animation:pvSlideRight 0.6s cubic-bezier(0.16,1,0.3,1) ${i*0.1}s forwards;`;
        container.appendChild(span);
        
        // 每个字出现时产生一个扩散波纹（打水漂效果）
        const wave = document.createElement('div');
        const xPos = i * 4.5; // 每个字的位置（rem）
        wave.style.cssText = `
            position:absolute;
            top:50%;
            left:calc(${xPos}rem + 2.25rem);
            width:40px;
            height:40px;
            border:2px solid rgba(58,130,196,0.7);
            border-radius:50%;
            transform:translate(-50%,-50%) scale(0);
            opacity:0;
            animation:pvRipple 1s ease ${i*0.1}s forwards;
        `;
        waveContainer.appendChild(wave);
    });
    overlay.appendChild(container);
    
    // 44.5秒时在图片上出现大的扩散波纹
    // 歌词在41.73秒出现，44.5秒 - 41.73秒 = 2.77秒后
    setTimeout(() => {
        const bigWave = document.createElement('div');
        bigWave.style.cssText = `
            position:absolute;
            top:50%;
            left:50%;
            width:100px;
            height:100px;
            border:1.5px solid rgba(58,130,196,0.8);
            border-radius:50%;
            transform:translate(-50%,-50%) scale(0);
            animation:pvBigRipple 1.5s ease forwards;
            z-index:100;
        `;
        overlay.appendChild(bigWave);
    }, 2770);
}

// 歌词6: "你即是我，我即是你" - 字符互换效果
// 场景9：第一张图淡青蓝色，第二张图暗红色
function renderLyric6(overlay, text) {
    // 在网页中央显示"你即是我"，49.2秒时"你"和"我"互换变成"我即是你"
    // 场景9开始于46秒，歌词在46.52秒显示，49.2秒切换 = 歌词显示后约2.68秒
    
    const container = document.createElement('div');
    container.id = 'lyric6Container';
    container.className = 'pv-custom-line';
    container.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:4.5rem;white-space:nowrap;perspective:800px;text-shadow:none;';
    
    // 创建每个字符的span，方便后续动画
    const chars = ['"', '你', '即', '是', '我', '"'];
    
    // 青蓝色阴影（配合第一张图）- 参考pv-custom-line样式
    const cyanShadow = 'text-shadow: 0 0 30px rgba(88,166,196,0.8), 0 0 60px rgba(88,166,196,0.5), 4px 4px 0 #1a4a6a;';
    
    chars.forEach((char, i) => {
        const span = document.createElement('span');
        span.className = 'lyric6-char';
        span.setAttribute('data-index', i);
        span.textContent = char;
        span.style.cssText = `
            display: inline-block;
            opacity: 0;
            color: #e0f4ff;
            font-weight: 900;
            letter-spacing: 0.1em;
            ${cyanShadow}
            transform-style: preserve-3d;
            animation: lyric6CharIn 0.6s cubic-bezier(0.34,1.56,0.64,1) ${i * 0.1}s forwards;
        `;
        container.appendChild(span);
    });
    
    overlay.appendChild(container);
    
    // 添加动画样式
    const style = document.createElement('style');
    style.textContent = `
        @keyframes lyric6CharIn {
            0% { opacity: 0; transform: translateY(-30px) scale(0.5); filter: blur(10px); }
            100% { opacity: 1; transform: translateY(0) scale(1); filter: blur(0); }
        }
        @keyframes lyric6CharSwap {
            0% { transform: scale(1) rotateY(0deg) translateX(0); opacity: 1; filter: blur(0); }
            20% { transform: scale(1.5) rotateY(45deg) translateX(-10px); opacity: 0.8; filter: blur(2px); }
            45% { transform: scale(2) rotateY(90deg) translateX(0); opacity: 0; filter: blur(5px); }
            55% { transform: scale(2) rotateY(-90deg) translateX(0); opacity: 0; filter: blur(5px); }
            80% { transform: scale(1.5) rotateY(-45deg) translateX(10px); opacity: 0.8; filter: blur(2px); }
            100% { transform: scale(1) rotateY(0deg) translateX(0); opacity: 1; filter: blur(0); }
        }
        @keyframes lyric6Glitch {
            0%, 100% { transform: translate(-50%, -50%); filter: none; }
            10% { transform: translate(calc(-50% - 8px), calc(-50% + 5px)); filter: hue-rotate(90deg); }
            20% { transform: translate(calc(-50% + 10px), calc(-50% - 6px)); filter: hue-rotate(180deg); }
            30% { transform: translate(calc(-50% - 6px), calc(-50% + 8px)); filter: hue-rotate(270deg); }
            40% { transform: translate(calc(-50% + 8px), calc(-50% - 4px)); filter: hue-rotate(360deg); }
            50% { transform: translate(calc(-50% - 4px), calc(-50% + 3px)); filter: hue-rotate(45deg); }
            60% { transform: translate(calc(-50% + 5px), calc(-50% - 5px)); filter: hue-rotate(135deg); }
            70% { transform: translate(calc(-50% - 3px), calc(-50% + 2px)); filter: hue-rotate(225deg); }
            80% { transform: translate(calc(-50% + 2px), calc(-50% - 2px)); filter: hue-rotate(315deg); }
            90% { transform: translate(calc(-50% - 1px), calc(-50% + 1px)); filter: none; }
        }
        @keyframes lyric6RGBSplit {
            0%, 100% { text-shadow: 0 0 30px rgba(88,166,196,0.8), 0 0 60px rgba(88,166,196,0.5), 4px 4px 0 #1a4a6a; }
            25% { text-shadow: -8px 0 0 rgba(255,0,0,0.8), 8px 0 0 rgba(0,255,255,0.8), 0 0 30px rgba(255,255,255,0.5); }
            50% { text-shadow: 10px 0 0 rgba(255,0,100,0.8), -10px 0 0 rgba(0,200,255,0.8), 0 0 40px rgba(255,255,255,0.8); }
            75% { text-shadow: -5px 3px 0 rgba(255,50,50,0.8), 5px -3px 0 rgba(50,255,255,0.8), 0 0 20px rgba(255,255,255,0.3); }
        }
        @keyframes lyric6Flicker {
            0% { opacity: 1; }
            10% { opacity: 0.2; }
            20% { opacity: 1; }
            30% { opacity: 0.4; }
            40% { opacity: 1; }
            50% { opacity: 0.1; }
            60% { opacity: 0.8; }
            70% { opacity: 0.3; }
            80% { opacity: 1; }
            90% { opacity: 0.6; }
            100% { opacity: 1; }
        }
    `;
    overlay.appendChild(style);
    
    // 2.68秒后（49.2秒时）执行字符互换
    setTimeout(() => {
        const allChars = container.querySelectorAll('.lyric6-char');
        const char1 = allChars[1]; // "你"
        const char4 = allChars[4]; // "我"
        
        if (char1 && char4) {
            // 整体强烈故障抖动 + 色相偏移
            container.style.animation = 'lyric6Glitch 0.5s ease forwards, lyric6Flicker 0.5s steps(2) forwards';
            
            // 所有字符RGB分离效果
            allChars.forEach(span => {
                span.style.animation = 'lyric6RGBSplit 0.5s ease forwards';
            });
            
            // 要切换的两个字符特殊翻转动画
            char1.style.animation = 'lyric6CharSwap 0.6s ease forwards, lyric6RGBSplit 0.5s ease forwards';
            char4.style.animation = 'lyric6CharSwap 0.6s ease forwards, lyric6RGBSplit 0.5s ease forwards';
            
            // 0.3秒后（翻转到一半时）更换文字内容
            setTimeout(() => {
                char1.textContent = '我';
                char4.textContent = '你';
            }, 300);
            
            // 翻转完成后，所有字符变为暗红色调（参考pv-custom-line的红色阴影样式）
            setTimeout(() => {
                // 重置容器动画
                container.style.animation = 'none';
                container.style.opacity = '1';
                container.style.transform = 'translate(-50%, -50%)';
                container.style.filter = 'none';
                
                // 重置所有字符
                allChars.forEach(span => {
                    span.style.animation = 'none';
                    span.style.opacity = '1';
                    span.style.transform = 'none';
                    span.style.filter = 'none';
                    span.style.transition = 'color 0.5s ease, text-shadow 0.5s ease';
                    span.style.color = '#fff';
                    span.style.textShadow = '0 0 30px rgba(196,30,58,0.8), 0 0 60px rgba(196,30,58,0.5), 4px 4px 0 #8b0000';
                });
            }, 600);
        }
    }, 2680);
    
    // 51秒时（歌词显示后约4.48秒）"我"和"你"瞬间故障崩坏色彩分离
    setTimeout(() => {
        const allChars = container.querySelectorAll('.lyric6-char');
        const charWo = allChars[1]; // 现在是"我"
        const charNi = allChars[4]; // 现在是"你"
        
        if (charWo && charNi) {
            // 添加瞬间故障崩坏动画样式
            const glitchStyle = document.createElement('style');
            glitchStyle.textContent = `
                @keyframes lyric6InstantGlitch {
                    0% { transform: translate(0, 0); }
                    10% { transform: translate(-5px, 3px) skewX(5deg); }
                    20% { transform: translate(6px, -4px) skewX(-8deg); }
                    30% { transform: translate(-4px, 5px) skewX(10deg); }
                    40% { transform: translate(5px, -3px) skewX(-5deg); }
                    50% { transform: translate(-3px, 2px) skewX(3deg); }
                    60% { transform: translate(4px, -2px) skewX(-3deg); }
                    70% { transform: translate(-2px, 1px) skewX(2deg); }
                    80% { transform: translate(1px, -1px) skewX(-1deg); }
                    90% { transform: translate(-1px, 0) skewX(0); }
                    100% { transform: translate(0, 0) skewX(0); }
                }
                @keyframes lyric6InstantRGB {
                    0% { text-shadow: 0 0 30px rgba(196,30,58,0.8), 0 0 60px rgba(196,30,58,0.5), 4px 4px 0 #8b0000; }
                    15% { text-shadow: -12px 0 0 rgba(255,0,0,0.9), 12px 0 0 rgba(0,255,255,0.9), 0 -8px 0 rgba(255,0,255,0.7), 0 0 50px rgba(255,255,255,0.8); }
                    30% { text-shadow: 15px 0 0 rgba(255,50,50,0.9), -15px 0 0 rgba(50,255,255,0.9), 0 10px 0 rgba(255,50,255,0.7), 0 0 60px rgba(255,255,255,1); }
                    45% { text-shadow: -10px 5px 0 rgba(255,0,100,0.8), 10px -5px 0 rgba(0,200,255,0.8), 5px 8px 0 rgba(200,0,255,0.6); }
                    60% { text-shadow: 8px -3px 0 rgba(255,100,0,0.7), -8px 3px 0 rgba(0,150,255,0.7), -3px -5px 0 rgba(150,0,255,0.5); }
                    75% { text-shadow: -5px 2px 0 rgba(255,0,0,0.5), 5px -2px 0 rgba(0,255,255,0.5), 0 0 30px rgba(196,30,58,0.6); }
                    100% { text-shadow: 0 0 30px rgba(196,30,58,0.8), 0 0 60px rgba(196,30,58,0.5), 4px 4px 0 #8b0000; }
                }
                @keyframes lyric6InstantFlicker {
                    0%, 100% { opacity: 1; }
                    15% { opacity: 0.1; }
                    30% { opacity: 0.9; }
                    45% { opacity: 0.2; }
                    60% { opacity: 0.8; }
                    75% { opacity: 0.3; }
                    90% { opacity: 1; }
                }
            `;
            overlay.appendChild(glitchStyle);
            
            // 对"我"和"你"应用瞬间故障效果
            [charWo, charNi].forEach(char => {
                char.style.animation = 'lyric6InstantGlitch 0.3s ease, lyric6InstantRGB 0.3s ease, lyric6InstantFlicker 0.3s steps(2)';
            });
            
            // 动画结束后重置
            setTimeout(() => {
                [charWo, charNi].forEach(char => {
                    char.style.animation = 'none';
                    char.style.textShadow = '0 0 30px rgba(196,30,58,0.8), 0 0 60px rgba(196,30,58,0.5), 4px 4px 0 #8b0000';
                });
            }, 300);
        }
    }, 4480); // 51秒 - 46.52秒 = 4.48秒
}

// 歌词7: "如同绽放在虚空中的花朵" - 旋转舞动效果（与歌词8一致）
function renderLyric7(overlay, text) {
    // 旋转光环（在背后）- 带呼吸感的圆形
    const ring = document.createElement('div');
    ring.style.cssText = 'position:absolute;top:50%;left:50%;width:400px;height:400px;border:2px solid rgba(196,30,58,0.5);border-radius:50%;transform:translate(-50%,-50%);animation:pvRingFadeIn 0.6s ease forwards, pvRingBreath 4s ease-in-out infinite;z-index:1;';
    overlay.appendChild(ring);
    
    const container = document.createElement('div');
    container.className = 'pv-custom-line';
    container.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:3.5rem;white-space:nowrap;z-index:2;';
    
    text.split('').forEach((char, i) => {
        const span = document.createElement('span');
        span.textContent = char;
        span.style.cssText = `display:inline-block;opacity:0;transform:translateY(-80px) rotate(${(i-text.length/2)*15}deg);animation:pvDanceIn 0.8s cubic-bezier(0.34,1.56,0.64,1) ${i*0.06}s forwards;`;
        container.appendChild(span);
    });
    overlay.appendChild(container);
}

// 歌词8: "背负着毁灭之命起舞" - 旋转舞动效果
function renderLyric8(overlay, text) {
    // 旋转光环（在背后）- 带呼吸感的圆形
    const ring = document.createElement('div');
    ring.style.cssText = 'position:absolute;top:50%;left:50%;width:400px;height:400px;border:2px solid rgba(196,30,58,0.5);border-radius:50%;transform:translate(-50%,-50%);animation:pvRingFadeIn 0.6s ease forwards, pvRingBreath 4s ease-in-out infinite;z-index:1;';
    overlay.appendChild(ring);
    
    const container = document.createElement('div');
    container.className = 'pv-custom-line';
    container.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:3.5rem;white-space:nowrap;z-index:2;';
    
    text.split('').forEach((char, i) => {
        const span = document.createElement('span');
        span.textContent = char;
        span.style.cssText = `display:inline-block;opacity:0;transform:translateY(-80px) rotate(${(i-text.length/2)*15}deg);animation:pvDanceIn 0.8s cubic-bezier(0.34,1.56,0.64,1) ${i*0.06}s forwards;`;
        container.appendChild(span);
    });
    overlay.appendChild(container);
}

// 歌词9: "这份痛楚将化作利剑" - 剑刃切割效果
function renderLyric9(overlay, text) {
    const part1 = '这份痛楚';
    const part2 = '将化作利剑';
    
    // 第一部分 - 左上
    const line1 = document.createElement('div');
    line1.className = 'pv-custom-line';
    line1.style.cssText = 'position:absolute;top:30%;left:15%;font-size:3rem;opacity:0;transform:translateX(-100px);animation:pvSlideRight 0.6s ease forwards;';
    line1.textContent = part1;
    overlay.appendChild(line1);
    
    // 第二部分 - 右下，更大
    const line2 = document.createElement('div');
    line2.className = 'pv-custom-line';
    line2.style.cssText = 'position:absolute;top:55%;right:10%;font-size:4.5rem;opacity:0;transform:translateX(100px);animation:pvSlideLeftBig 0.6s ease 0.3s forwards;color:#ff4757;text-shadow:0 0 30px #ff4757,4px 4px 0 #8b0000;';
    line2.textContent = part2;
    overlay.appendChild(line2);
}

// 歌词10: "以Tulpa之名，撕裂这世界！" - 终极高潮爆发效果
function renderLyric10(overlay, text) {
    const part1 = '以Tulpa之名，';
    const part2 = '撕裂这世界！';
    
    // 添加专属动画样式
    const style = document.createElement('style');
    style.textContent = `
        @keyframes lyric10Part1In {
            0% { opacity: 0; transform: translateY(-50px) scale(0.8); filter: blur(10px); }
            60% { opacity: 1; transform: translateY(5px) scale(1.05); filter: blur(0); }
            100% { opacity: 1; transform: translateY(0) scale(1); filter: blur(0); }
        }
        @keyframes lyric10TearIn {
            0% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scaleX(0) scaleY(3); 
                filter: blur(20px);
                letter-spacing: -0.3em;
            }
            30% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scaleX(1.3) scaleY(0.7); 
                filter: blur(5px);
                letter-spacing: 0.1em;
            }
            50% { 
                transform: translate(-50%, -50%) scaleX(0.95) scaleY(1.1); 
                filter: blur(0);
                letter-spacing: 0.15em;
            }
            70% { 
                transform: translate(-50%, -50%) scaleX(1.05) scaleY(0.98); 
                letter-spacing: 0.12em;
            }
            100% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scaleX(1) scaleY(1); 
                filter: blur(0);
                letter-spacing: 0.1em;
            }
        }
        @keyframes lyric10Shockwave {
            0% { width: 0; height: 0; opacity: 0.8; }
            100% { width: 200vmax; height: 200vmax; opacity: 0; }
        }
        @keyframes lyric10SlashLeft {
            0% { transform: translate(-50%, -50%) rotate(-45deg) scaleX(0); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translate(-50%, -50%) rotate(-45deg) scaleX(1); opacity: 0; }
        }
        @keyframes lyric10SlashRight {
            0% { transform: translate(-50%, -50%) rotate(45deg) scaleX(0); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translate(-50%, -50%) rotate(45deg) scaleX(1); opacity: 0; }
        }
        @keyframes lyric10CharGlitch {
            0%, 100% { transform: translate(0, 0); text-shadow: 0 0 30px rgba(196,30,58,0.8), 0 0 60px rgba(196,30,58,0.5), 4px 4px 0 #8b0000; }
            20% { transform: translate(-3px, 2px); text-shadow: -5px 0 #00ffff, 5px 0 #ff00ff, 0 0 30px rgba(255,255,255,0.8); }
            40% { transform: translate(3px, -2px); text-shadow: 5px 0 #00ffff, -5px 0 #ff00ff, 0 0 30px rgba(255,255,255,0.8); }
            60% { transform: translate(-2px, -1px); text-shadow: -3px 0 #ff0000, 3px 0 #00ffff, 0 0 20px rgba(255,255,255,0.5); }
            80% { transform: translate(2px, 1px); text-shadow: 3px 0 #ff0000, -3px 0 #00ffff, 0 0 20px rgba(255,255,255,0.5); }
        }
        @keyframes lyric10ScreenFlash {
            0% { opacity: 0; }
            10% { opacity: 0.8; }
            100% { opacity: 0; }
        }
    `;
    overlay.appendChild(style);
    
    // 第一部分 - 中上方，逐字爆发（立即开始）
    const line1 = document.createElement('div');
    line1.className = 'pv-custom-line';
    line1.style.cssText = 'position:absolute;top:25%;left:50%;transform:translateX(-50%);font-size:3rem;white-space:nowrap;';
    part1.split('').forEach((char, i) => {
        const span = document.createElement('span');
        span.textContent = char;
        span.style.cssText = `display:inline-block;opacity:0;animation:lyric10Part1In 0.6s cubic-bezier(0.34,1.56,0.64,1) ${i*0.06}s forwards;`;
        line1.appendChild(span);
    });
    overlay.appendChild(line1);
    
    // 第二部分 - 中央，超大霸气撕裂效果（延迟2.44秒后开始，即69.7秒时）
    const line2 = document.createElement('div');
    line2.className = 'pv-custom-line';
    line2.id = 'lyric10Part2';
    line2.style.cssText = `
        position:absolute;top:50%;left:50%;
        transform:translate(-50%,-50%) scaleX(0);
        font-size:5.5rem;font-weight:900;
        opacity:0;
        color:#fff;
        text-shadow:0 0 30px rgba(255,45,85,1), 0 0 60px rgba(196,30,58,0.8), 0 0 100px rgba(196,30,58,0.5), 6px 6px 0 #8b0000;
        white-space:nowrap;
        letter-spacing:0.1em;
        animation:lyric10TearIn 0.8s cubic-bezier(0.16,1,0.3,1) 2.44s forwards;
    `;
    line2.textContent = part2;
    overlay.appendChild(line2);
    
    // 2.44秒后触发冲击波和斜线特效
    setTimeout(() => {
        // 屏幕闪白
        const flash = document.createElement('div');
        flash.style.cssText = 'position:absolute;inset:0;background:rgba(255,255,255,0.8);animation:lyric10ScreenFlash 0.3s ease forwards;pointer-events:none;z-index:100;';
        overlay.appendChild(flash);
        setTimeout(() => flash.remove(), 300);
        
        // 中心冲击波
        const shockwave = document.createElement('div');
        shockwave.style.cssText = `
            position:absolute;top:50%;left:50%;
            transform:translate(-50%,-50%);
            border:3px solid rgba(255,45,85,0.8);
            border-radius:50%;
            animation:lyric10Shockwave 1s ease-out forwards;
            pointer-events:none;
        `;
        overlay.appendChild(shockwave);
        
        // 第二层冲击波
        setTimeout(() => {
            const shockwave2 = document.createElement('div');
            shockwave2.style.cssText = `
                position:absolute;top:50%;left:50%;
                transform:translate(-50%,-50%);
                border:2px solid rgba(255,255,255,0.6);
                border-radius:50%;
                animation:lyric10Shockwave 1.2s ease-out forwards;
                pointer-events:none;
            `;
            overlay.appendChild(shockwave2);
        }, 100);
        
        // X形斜线撕裂特效
        const slashLeft = document.createElement('div');
        slashLeft.style.cssText = `
            position:absolute;top:50%;left:50%;
            width:200vw;height:4px;
            background:linear-gradient(90deg, transparent, #ff2d55, #fff, #ff2d55, transparent);
            transform:translate(-50%,-50%) rotate(-45deg) scaleX(0);
            animation:lyric10SlashLeft 0.5s ease-out forwards;
            pointer-events:none;
        `;
        overlay.appendChild(slashLeft);
        
        const slashRight = document.createElement('div');
        slashRight.style.cssText = `
            position:absolute;top:50%;left:50%;
            width:200vw;height:4px;
            background:linear-gradient(90deg, transparent, #ff2d55, #fff, #ff2d55, transparent);
            transform:translate(-50%,-50%) rotate(45deg) scaleX(0);
            animation:lyric10SlashRight 0.5s ease-out 0.1s forwards;
            pointer-events:none;
        `;
        overlay.appendChild(slashRight);
        
        // 文字故障闪烁效果
        setTimeout(() => {
            const line2El = document.getElementById('lyric10Part2');
            if (line2El) {
                line2El.style.animation = 'lyric10CharGlitch 0.4s ease';
                setTimeout(() => {
                    line2El.style.animation = 'none';
                    line2El.style.opacity = '1';
                    line2El.style.transform = 'translate(-50%,-50%)';
                }, 400);
            }
        }, 600);
    }, 2440);
}

function updatePvLyrics() {
    if (isAlbumMode) return;
    const t = bgMusic.currentTime * 1000;
    
    // 只在20590ms到67260ms之间显示PV歌词
    if (t < 20590 || t > 72000) {
        currentPvLyricIndex = -1;
        return;
    }
    
    for (let i = lyrics.length - 1; i >= 0; i--) {
        if (t >= lyrics[i].time && lyrics[i].pvAnim) {
            if (i !== currentPvLyricIndex) {
                currentPvLyricIndex = i;
                showPvLyric(lyrics[i]);
            }
            break;
        }
    }
}

function showLyric(lyric) {
    lyricCn.classList.add('lyric-exit-blur');
    lyricJp.classList.add('lyric-exit-blur');
    setTimeout(() => {
        lyricCn.className = 'lyric-line';
        lyricJp.className = 'lyric-line jp';
        switch(lyric.animIn) {
            case 'typewriter':
                lyricCn.innerHTML = lyric.cn.split('').map((c,i) => `<span class="lyric-char" style="animation-delay:${i*0.04}s">${c}</span>`).join('');
                lyricJp.innerHTML = lyric.jp.split('').map((c,i) => `<span class="lyric-char" style="animation-delay:${i*0.04+0.2}s">${c}</span>`).join('');
                lyricCn.classList.add('lyric-anim-typewriter'); lyricJp.classList.add('lyric-anim-typewriter');
                lyricCn.style.opacity = '1'; lyricJp.style.opacity = '1';
                break;
            case 'wave':
                lyricCn.innerHTML = lyric.cn.split('').map((c,i) => `<span class="lyric-char" style="animation-delay:${i*0.05}s">${c}</span>`).join('');
                lyricJp.innerHTML = lyric.jp.split('').map((c,i) => `<span class="lyric-char" style="animation-delay:${i*0.05+0.15}s">${c}</span>`).join('');
                lyricCn.classList.add('lyric-anim-wave'); lyricJp.classList.add('lyric-anim-wave');
                lyricCn.style.opacity = '1'; lyricJp.style.opacity = '1';
                break;
            case 'scatter':
                lyricCn.innerHTML = lyric.cn.split('').map((c,i) => `<span class="lyric-char" style="--r1:${Math.random()};--r2:${Math.random()};animation-delay:${i*0.03}s">${c}</span>`).join('');
                lyricJp.innerHTML = lyric.jp.split('').map((c,i) => `<span class="lyric-char" style="--r1:${Math.random()};--r2:${Math.random()};animation-delay:${i*0.03+0.1}s">${c}</span>`).join('');
                lyricCn.classList.add('lyric-anim-scatter'); lyricJp.classList.add('lyric-anim-scatter');
                lyricCn.style.opacity = '1'; lyricJp.style.opacity = '1';
                break;
            case 'glitch':
                lyricCn.textContent = lyric.cn; lyricJp.textContent = lyric.jp;
                lyricCn.classList.add('lyric-anim-glitch'); lyricJp.classList.add('lyric-anim-glitch');
                lyricJp.style.animationDelay = '0.1s';
                break;
            case '3d':
                lyricCn.textContent = lyric.cn; lyricJp.textContent = lyric.jp;
                lyricCn.classList.add('lyric-anim-3d'); lyricJp.classList.add('lyric-anim-3d');
                lyricJp.style.animationDelay = '0.2s';
                break;
            default:
                lyricCn.textContent = lyric.cn; lyricJp.textContent = lyric.jp;
                lyricCn.classList.add('lyric-anim-blur'); lyricJp.classList.add('lyric-anim-blur');
                lyricJp.style.animationDelay = '0.15s';
        }
    }, 250);
}

function updateLyrics() {
    if (isAlbumMode) {
        // 相册模式下确保歌词隐藏
        if (!lyricsContainer.classList.contains('hidden')) {
            lyricsContainer.classList.add('hidden');
        }
        // PV歌词在transitionToAlbum中延迟清除，这里不处理
        return;
    }
    
    // 更新PV画面歌词
    updatePvLyrics();
    
    const t = bgMusic.currentTime * 1000;
    for (let i = lyrics.length - 1; i >= 0; i--) {
        if (t >= lyrics[i].time) {
            if (i !== currentLyricIndex) { currentLyricIndex = i; showLyric(lyrics[i]); }
            break;
        }
    }
}

// ==================== 场景 ====================
function clearSequences() { sequenceIntervals.forEach(id => clearInterval(id)); sequenceIntervals = []; }

function updateScene() {
    if (isAlbumMode) {
        // 相册模式下确保场景隐藏
        if (!sceneContainer.classList.contains('fade-out')) {
            sceneContainer.classList.add('fade-out');
        }
        return;
    }
    const t = bgMusic.currentTime * 1000;
    if (t >= PV_END_TIME) { transitionToAlbum(); return; }
    for (let i = sceneTimeline.length - 1; i >= 0; i--) {
        if (t >= sceneTimeline[i].time) {
            if (i !== currentSceneIndex) {
                currentSceneIndex = i;
                clearSequences();
                playTransition(sceneTimeline[i].transition);
                setTimeout(() => renderScene(sceneTimeline[i]), 300);
            }
            break;
        }
    }
}

function renderScene(scene) {
    // 处理图片系列
    let images = [];
    if (scene.series) {
        if (scene.series === 'all') {
            // 使用所有图片
            images = allImages;
        } else if (scene.series === 'first-only') {
            // 只使用每个系列的第一张图片
            images = firstImagesOnly;
        } else if (scene.series === 'scene1-extended') {
            // 场景1的扩展图片列表
            images = scene1Images;
        } else if (Array.isArray(scene.series)) {
            // 多个系列
            images = scene.series.flatMap(s => imageSeries[s]);
        } else {
            // 单个系列
            images = imageSeries[scene.series];
        }
    }
    
    switch(scene.type) {
        case 'intro': renderIntro(); break;
        case 'mirror-sequence': renderMirrorSequence(images); break;
        case 'glass-shatter': renderGlassShatter(images); break;
        case 'expression-loop': renderExpressionLoop(images); break;
        case 'single-dramatic': renderSingleDramatic(images); break;
        case 'split-morph': renderSplitMorph(images); break;
        case 'quad-grid': renderQuadGrid(images); break;
        case 'whisper-float': renderWhisperFloat(images); break;
        case 'tulpa-duality': renderTulpaDuality(images); break;
        case 'rapid-sequence': renderRapidSequence(images); break;
        case 'dance-montage': renderDanceMontage(images); break;
        case 'world-tear-finale': renderWorldTearFinale(images); break;
        case 'scene13-placeholder': renderScene13(images); break;
    }
}

// 待机画面 - loading后、点击播放前显示的简单标题
function renderWaitingScreen() {
    sceneContainer.innerHTML = `
        <div class="main-canvas" style="flex-direction:column;position:relative;">
            <!-- 波浪扩散容器 -->
            <div id="rippleContainer" style="position:absolute;inset:0;pointer-events:none;overflow:hidden;z-index:100;"></div>
            
            <!-- 标题容器 -->
            <div style="display:flex;flex-direction:column;align-items:center;">
                <div style="overflow:hidden;">
                    <h1 style="font-size:4.5rem;font-weight:900;color:#fff;letter-spacing:0.25em;text-shadow:6px 6px 0 #8b0000,12px 12px 0 #000;animation:imgSlideUp 1.2s cubic-bezier(0.16,1,0.3,1) forwards;">不/存在的你，和我</h1>
                </div>
                <div style="width:0;height:3px;background:linear-gradient(90deg,transparent,#c41e3a,transparent);margin:30px 0;animation:expandW 1.5s ease 0.5s forwards;"></div>
                <p style="font-size:1.6rem;color:#c41e3a;letter-spacing:1em;opacity:0;animation:blurIn 1s ease 1s forwards;">TULPA · 莉莉丝</p>
            </div>
            
            <!-- 独立播放按钮 -->
            <button id="waitingPlayBtn" style="
                margin-top:60px;
                width:80px;
                height:80px;
                border:3px solid #c41e3a;
                background:transparent;
                border-radius:50%;
                cursor:pointer;
                display:flex;
                align-items:center;
                justify-content:center;
                opacity:0;
                transition:all 0.3s ease;
                animation:blurIn 1s ease 2.3s forwards, hintPulse 2s ease-in-out 3.3s infinite;
                position:relative;
                z-index:10;
            " onmouseover="this.style.background='#c41e3a';this.style.boxShadow='0 0 30px rgba(196,30,58,0.8)'" onmouseout="this.style.background='transparent';this.style.boxShadow='none'">
                <svg viewBox="0 0 24 24" style="width:35px;height:35px;fill:#fff;margin-left:3px;">
                    <polygon points="5,3 19,12 5,21"/>
                </svg>
            </button>
        </div>
    `;
    
    // 绑定播放按钮事件
    setTimeout(() => {
        const waitingPlayBtn = document.getElementById('waitingPlayBtn');
        if (waitingPlayBtn) {
            waitingPlayBtn.addEventListener('click', (e) => {
                // 创建波浪扩散效果
                createRippleEffect(e.target);
                
                // 快速开始播放
                setTimeout(() => {
                    playBtn.click();
                }, 100);
            });
        }
    }, 100);
}

// 创建红色波浪扩散效果
function createRippleEffect(btn) {
    const container = document.getElementById('rippleContainer');
    if (!container) return;
    
    // 获取按钮中心位置
    const rect = btn.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2 - containerRect.left;
    const centerY = rect.top + rect.height / 2 - containerRect.top;
    
    // 创建单层波浪
    const ripple = document.createElement('div');
    ripple.style.cssText = `
        position: absolute;
        left: ${centerX}px;
        top: ${centerY}px;
        width: 0;
        height: 0;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        border: 4px solid rgba(196, 30, 58, 0.8);
        box-shadow: 0 0 30px rgba(196, 30, 58, 0.6),
                    inset 0 0 15px rgba(196, 30, 58, 0.3);
        animation: rippleExpand 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    `;
    container.appendChild(ripple);
    
    // 动画结束后移除
    setTimeout(() => ripple.remove(), 1800);
    
    // 添加中心闪光
    const flash = document.createElement('div');
    flash.style.cssText = `
        position: absolute;
        left: ${centerX}px;
        top: ${centerY}px;
        width: 100px;
        height: 100px;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(196,30,58,0.8) 30%, transparent 70%);
        animation: rippleFlash 0.5s ease-out forwards;
    `;
    container.appendChild(flash);
    setTimeout(() => flash.remove(), 500);
}

// PV场景2 - 0:08时的炫酷标题入场
function renderIntro() {
    const titleText = '不/存在的你，和我';
    const subtitleText = 'TULPA · 莉莉丝';
    
    // 每个字符可能的入场动画
    const charAnimations = [
        { transform: 'translateY(-200px) rotate(-180deg)', filter: 'blur(10px)' },
        { transform: 'translateY(200px) rotate(180deg)', filter: 'blur(10px)' },
        { transform: 'translateX(-300px) rotate(-90deg)', filter: 'blur(8px)' },
        { transform: 'translateX(300px) rotate(90deg)', filter: 'blur(8px)' },
        { transform: 'scale(3) rotate(360deg)', filter: 'blur(15px)' },
        { transform: 'scale(0) rotate(-360deg)', filter: 'blur(20px)' },
        { transform: 'translate(-150px, -150px) rotate(-45deg) scale(0.3)', filter: 'blur(5px)' },
        { transform: 'translate(150px, 150px) rotate(45deg) scale(0.3)', filter: 'blur(5px)' },
        { transform: 'translate(-200px, 100px) rotate(720deg) scale(2)', filter: 'blur(12px)' },
        { transform: 'translate(200px, -100px) rotate(-720deg) scale(0.1)', filter: 'blur(18px)' },
        { transform: 'perspective(500px) rotateX(90deg) translateZ(100px)', filter: 'blur(8px)' },
        { transform: 'perspective(500px) rotateY(90deg) translateZ(100px)', filter: 'blur(8px)' },
    ];
    
    sceneContainer.innerHTML = `
        <div class="main-canvas" style="flex-direction:column;position:relative;overflow:hidden;">
            <!-- 粒子背景层 -->
            <div id="particleContainer" style="position:absolute;inset:0;pointer-events:none;z-index:1;"></div>
            
            <!-- 闪光线条层 -->
            <div id="flashLines" style="position:absolute;inset:0;pointer-events:none;z-index:2;"></div>
            
            <!-- 中心爆发光效 -->
            <div id="burstEffect" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:0;height:0;border-radius:50%;background:radial-gradient(circle,rgba(196,30,58,0.8) 0%,transparent 70%);z-index:3;animation:burstExpand 1.5s ease-out forwards;"></div>
            
            <!-- 摄像机容器 - 通过移动这个容器模拟摄像机运动 -->
            <div id="cameraContainer" style="position:relative;z-index:10;display:flex;flex-direction:column;align-items:center;transform-origin:center center;">
                <!-- 主标题容器 -->
                <div id="titleContainer" style="display:flex;font-size:4.5rem;font-weight:900;letter-spacing:0.25em;"></div>
                
                <!-- 装饰线条 -->
                <div id="titleLine" style="width:0;height:3px;background:linear-gradient(90deg,transparent,#c41e3a,transparent);margin:30px 0;opacity:0;"></div>
                
                <!-- 副标题容器 -->
                <div id="subtitleContainer" style="display:flex;font-size:1.6rem;letter-spacing:1em;"></div>
            </div>
            
            <!-- 边框装饰 -->
            <div style="position:absolute;inset:50px;border:2px solid transparent;animation:borderDraw 2s ease 0.5s forwards;z-index:5;pointer-events:none;"></div>
        </div>
    `;
    
    // 生成粒子
    const particleContainer = document.getElementById('particleContainer');
    for (let i = 0; i < 80; i++) {
        const particle = document.createElement('div');
        const size = Math.random() * 8 + 2;
        const startX = Math.random() * 100;
        const startY = Math.random() * 100;
        const duration = Math.random() * 3 + 2;
        const delay = Math.random() * 1.5;
        
        particle.style.cssText = `
            position:absolute;
            width:${size}px;
            height:${size}px;
            background:${Math.random() > 0.5 ? '#c41e3a' : '#fff'};
            border-radius:50%;
            left:${startX}%;
            top:${startY}%;
            opacity:0;
            box-shadow:0 0 ${size * 2}px ${Math.random() > 0.5 ? '#c41e3a' : '#fff'};
            animation:particleFloat ${duration}s ease-in-out ${delay}s infinite;
        `;
        particleContainer.appendChild(particle);
    }
    
    // 生成闪光线条
    const flashLines = document.getElementById('flashLines');
    for (let i = 0; i < 12; i++) {
        const line = document.createElement('div');
        const angle = (i / 12) * 360;
        const delay = i * 0.05;
        
        line.style.cssText = `
            position:absolute;
            top:50%;
            left:50%;
            width:200vw;
            height:3px;
            background:linear-gradient(90deg,transparent,#c41e3a,#fff,#c41e3a,transparent);
            transform-origin:center;
            transform:translate(-50%,-50%) rotate(${angle}deg) scaleX(0);
            animation:lineFlash 0.6s ease-out ${delay}s forwards;
        `;
        flashLines.appendChild(line);
    }
    
    // 生成主标题字符 - 每个字符独立动画
    const titleContainer = document.getElementById('titleContainer');
    titleText.split('').forEach((char, i) => {
        const span = document.createElement('span');
        const anim = charAnimations[Math.floor(Math.random() * charAnimations.length)];
        const delay = 0.8 + i * 0.25; // 从0.8秒开始，每个字符间隔0.25秒（放慢）
        
        span.textContent = char;
        span.style.cssText = `
            display:inline-block;
            color:#fff;
            text-shadow:6px 6px 0 #8b0000, 12px 12px 0 #000;
            opacity:0;
            transform:${anim.transform};
            filter:${anim.filter};
            transition:all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
        `;
        titleContainer.appendChild(span);
        
        // 延迟后触发动画归位
        setTimeout(() => {
            span.style.opacity = '1';
            span.style.transform = 'translateY(0) rotate(0) scale(1)';
            span.style.filter = 'blur(0)';
        }, delay * 1000);
    });
    
    // 装饰线条动画
    setTimeout(() => {
        const line = document.getElementById('titleLine');
        if (line) {
            line.style.opacity = '1';
            line.style.transition = 'width 1s ease';
            line.style.width = '350px';
        }
    }, 2500);
    
    // 生成副标题字符 - 每个字符独立动画
    // 原本：从3秒开始，每个字符0.08秒间隔，0.5秒transition，约3.8秒完成
    // 修改：从2.5秒开始（去掉停顿），每个字符0.15秒间隔，0.8秒transition
    // 这样最后一个字符在 2.5 + 10*0.15 + 0.8 = 4.8秒完成，接近原来的时间节点
    const subtitleContainer = document.getElementById('subtitleContainer');
    subtitleText.split('').forEach((char, i) => {
        const span = document.createElement('span');
        const delay = 2.5 + i * 0.15; // 从2.5秒开始，间隔变长
        
        span.textContent = char;
        span.style.cssText = `
            display:inline-block;
            color:#c41e3a;
            opacity:0;
            transform:translateY(30px) scale(0.5);
            filter:blur(10px);
            transition:all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
        `;
        subtitleContainer.appendChild(span);
        
        setTimeout(() => {
            span.style.opacity = '1';
            span.style.transform = 'translateY(0) scale(1)';
            span.style.filter = 'blur(0)';
        }, delay * 1000);
    });
    
    // 主标题故障闪烁效果
    setTimeout(() => {
        const chars = titleContainer.querySelectorAll('span');
        let glitchCount = 0;
        const glitchInterval = setInterval(() => {
            chars.forEach((char, i) => {
                if (Math.random() > 0.5) {
                    char.style.textShadow = glitchCount % 2 === 0 
                        ? '6px 6px 0 #8b0000, 12px 12px 0 #000, -3px 0 #00ffff, 3px 0 #ff00ff'
                        : '6px 6px 0 #8b0000, 12px 12px 0 #000';
                    char.style.transform = glitchCount % 2 === 0 
                        ? `translateX(${(Math.random() - 0.5) * 4}px)`
                        : 'translateX(0)';
                }
            });
            glitchCount++;
            if (glitchCount > 8) {
                clearInterval(glitchInterval);
                chars.forEach(char => {
                    char.style.textShadow = '6px 6px 0 #8b0000, 12px 12px 0 #000';
                    char.style.transform = 'translateX(0)';
                });
            }
        }, 80);
    }, 2200);
    
    // ==================== 摄像机运动动画 ====================
    // 从场景2开始（0s）立即执行
    // 时间轴（无打转停留版本）：
    // 0s - 摄像机推近到"不"字
    // 1s - 从左向右平移，扫过主标题（2.4秒，放慢）
    // 3.4s - 下移到副标题左侧
    // 3.9s - 从左向右平移扫过副标题
    // 4.6s - 拉远回到原位，完整呈现整个标题
    
    const cameraContainer = document.getElementById('cameraContainer');
    if (cameraContainer) {
        // 立即推近到"不"字
        cameraContainer.style.transition = 'transform 0.6s cubic-bezier(0.4, 0, 0.2, 1)';
        cameraContainer.style.transform = 'scale(3) translate(35%, 20%)';
        
        // 阶段2: 1s - 从左向右平移扫过主标题（2.4秒，放慢以配合字符动画）
        setTimeout(() => {
            cameraContainer.style.transition = 'transform 2.4s cubic-bezier(0.4, 0, 0.2, 1)';
            cameraContainer.style.transform = 'scale(3) translate(-35%, 20%)';
        }, 1000);
        
        // 阶段3: 3.4s - 下移到副标题左侧（无打转停留，直接下移）
        setTimeout(() => {
            cameraContainer.style.transition = 'transform 0.5s cubic-bezier(0.4, 0, 0.2, 1)';
            cameraContainer.style.transform = 'scale(3) translate(25%, -30%)';
        }, 3400);
        
        // 阶段3.5: 3.9s - 从左向右平移扫过副标题
        setTimeout(() => {
            cameraContainer.style.transition = 'transform 0.7s cubic-bezier(0.4, 0, 0.2, 1)';
            cameraContainer.style.transform = 'scale(3) translate(-25%, -30%)';
        }, 3900);
        
        // 阶段4: 4.6s - 拉远回到原位
        setTimeout(() => {
            cameraContainer.style.transition = 'transform 0.8s cubic-bezier(0.4, 0, 0.2, 1)';
            cameraContainer.style.transform = 'scale(1) translate(0, 0)';
        }, 4600);
        
        // ==================== 丁达尔光线特效（0.8秒） ====================
        // 5.2s - 摄像机回位完成后，文字发出丁达尔光线
        setTimeout(() => {
            const titleContainer = document.getElementById('titleContainer');
            const subtitleContainer = document.getElementById('subtitleContainer');
            
            if (titleContainer) {
                titleContainer.classList.add('tyndall-effect');
                
                // 同时添加故障闪烁效果（增强版：更明显的偏移和抖动）
                const chars = titleContainer.querySelectorAll('span');
                let glitchCount = 0;
                const glitchInterval = setInterval(() => {
                    chars.forEach((char, i) => {
                        if (Math.random() > 0.5) {
                            char.style.textShadow = glitchCount % 2 === 0 
                                ? '6px 6px 0 #8b0000, 12px 12px 0 #000, -8px 0 #00ffff, 8px 0 #ff00ff'
                                : '6px 6px 0 #8b0000, 12px 12px 0 #000';
                            char.style.transform = glitchCount % 2 === 0 
                                ? `translate(${(Math.random() - 0.5) * 10}px, ${(Math.random() - 0.5) * 6}px)`
                                : 'translate(0, 0)';
                        }
                    });
                    glitchCount++;
                    if (glitchCount > 8) {
                        clearInterval(glitchInterval);
                        chars.forEach(char => {
                            char.style.textShadow = '6px 6px 0 #8b0000, 12px 12px 0 #000';
                            char.style.transform = 'translate(0, 0)';
                        });
                    }
                }, 80);
            }
            if (subtitleContainer) {
                subtitleContainer.classList.add('tyndall-glow-only');
            }
        }, 5200);
        
        // ==================== 大师级转场（场景2→场景3） ====================
        // 场景2从8秒开始，场景3从16秒开始
        // 转场在场景3开始前1秒触发，即场景2内的第7秒（15秒时）
        // 这样白屏闪烁正好衔接到场景3的玻璃破碎效果
        setTimeout(() => {
            // 创建转场容器
            const transitionOverlay = document.createElement('div');
            transitionOverlay.id = 'masterTransition';
            transitionOverlay.style.cssText = `
                position: fixed;
                inset: 0;
                z-index: 3000;
                pointer-events: none;
                overflow: hidden;
            `;
            document.body.appendChild(transitionOverlay);
            
            // 中心冲击波
            const shockwave = document.createElement('div');
            shockwave.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                width: 10px;
                height: 10px;
                background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(196,30,58,0.8) 30%, transparent 70%);
                border-radius: 50%;
                transform: translate(-50%, -50%);
                animation: shockwaveExpand 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            `;
            transitionOverlay.appendChild(shockwave);
            
            // 放射状裂纹
            for (let i = 0; i < 12; i++) {
                const crack = document.createElement('div');
                const angle = (i / 12) * 360;
                crack.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    width: 150vw;
                    height: 3px;
                    background: linear-gradient(90deg, rgba(255,255,255,0.9) 0%, rgba(196,30,58,0.8) 20%, transparent 50%);
                    transform-origin: left center;
                    transform: rotate(${angle}deg);
                    animation: crackExpand 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${i * 0.02}s forwards;
                    opacity: 0;
                `;
                transitionOverlay.appendChild(crack);
            }
            
            // 碎片飞散
            for (let i = 0; i < 20; i++) {
                const shard = document.createElement('div');
                const size = 20 + Math.random() * 60;
                const startX = 40 + Math.random() * 20;
                const startY = 40 + Math.random() * 20;
                const endX = (Math.random() - 0.5) * 200;
                const endY = (Math.random() - 0.5) * 200;
                const rotation = (Math.random() - 0.5) * 720;
                
                shard.style.cssText = `
                    position: absolute;
                    top: ${startY}%;
                    left: ${startX}%;
                    width: ${size}px;
                    height: ${size}px;
                    background: linear-gradient(135deg, rgba(196,30,58,0.6) 0%, rgba(139,0,0,0.4) 100%);
                    clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
                    opacity: 0;
                    animation: shardFly 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${0.1 + i * 0.02}s forwards;
                    --endX: ${endX}vw;
                    --endY: ${endY}vh;
                    --rotation: ${rotation}deg;
                `;
                transitionOverlay.appendChild(shard);
            }
            
            // 最终白屏闪烁 - 在场景3开始时触发（转场开始后0.8秒）
            setTimeout(() => {
                const finalFlash = document.createElement('div');
                finalFlash.style.cssText = `
                    position: fixed;
                    inset: 0;
                    background: white;
                    z-index: 3001;
                    animation: finalFlashOut 0.3s ease-out forwards;
                `;
                document.body.appendChild(finalFlash);
                setTimeout(() => finalFlash.remove(), 300);
            }, 800);
            
            // 清理转场元素
            setTimeout(() => {
                transitionOverlay.remove();
            }, 1200);
        }, 7700); // 场景2内的第7.7秒
    }
}

function renderMirrorSequence(images) {
    let idx = 0;
    sceneContainer.innerHTML = `
        <div class="main-canvas">
            <!-- 红色圆圈容器 - 在画框后面 -->
            <div id="mirrorRippleContainer" style="position:absolute;inset:0;pointer-events:none;z-index:1;"></div>
            <!-- 画框 - 在圆圈前面 -->
            <div class="pv-image border-double shadow-glow" id="mirrorFrame" style="width:480px;height:620px;animation:imgCircleReveal 0.8s ease forwards, frameZoomToFit 8s ease-in-out forwards;transform-origin:center center;position:relative;z-index:2;">
                <img id="mirrorImg" src="${images[0]}" style="width:100%;height:100%;object-fit:cover;">
            </div>
        </div>
    `;
    
    if (images.length > 1) { 
        const iv = setInterval(() => { 
            idx = (idx + 1) % images.length; 
            const img = document.getElementById('mirrorImg'); 
            if (img) { 
                img.src = images[idx]; 
            } 
        }, 250); 
        sequenceIntervals.push(iv); 
    }
    
    // 在第2.6秒添加红色圆圈扩散
    const rippleTimeout1 = setTimeout(() => {
        createSceneRipple('mirrorRippleContainer');
    }, 2600);
    sequenceIntervals.push(rippleTimeout1);
    
    // 在第5.4秒添加红色圆圈扩散
    const rippleTimeout2 = setTimeout(() => {
        createSceneRipple('mirrorRippleContainer');
    }, 5400);
    sequenceIntervals.push(rippleTimeout2);
}

// 为场景创建红色圆圈扩散效果（从中心扩散）
function createSceneRipple(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // 从容器中心扩散
    const centerX = container.offsetWidth / 2;
    const centerY = container.offsetHeight / 2;
    
    // 创建单层波浪
    const ripple = document.createElement('div');
    ripple.style.cssText = `
        position: absolute;
        left: ${centerX}px;
        top: ${centerY}px;
        width: 0;
        height: 0;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        border: 4px solid rgba(196, 30, 58, 0.8);
        box-shadow: 0 0 30px rgba(196, 30, 58, 0.6),
                    inset 0 0 15px rgba(196, 30, 58, 0.3);
        animation: rippleExpand 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    `;
    container.appendChild(ripple);
    
    // 动画结束后移除
    setTimeout(() => ripple.remove(), 1800);
    
    // 添加中心闪光
    const flash = document.createElement('div');
    flash.style.cssText = `
        position: absolute;
        left: ${centerX}px;
        top: ${centerY}px;
        width: 100px;
        height: 100px;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(196,30,58,0.8) 30%, transparent 70%);
        animation: rippleFlash 0.5s ease-out forwards;
    `;
    container.appendChild(flash);
    setTimeout(() => flash.remove(), 500);
}

// 场景3：玻璃碎片3D特效
function renderGlassShatter(images) {
    // 使用不同系列的图片，确保每个碎片图片来自不同系列
    const allAvailableImages = [
        '图片/莉莉丝1.png',      // 系列1
        '图片/莉莉丝23.png',      // 系列2
        '图片/莉莉丝18.png',      // 系列3
        '图片/莉莉丝4.png',      // 系列4
        '图片/莉莉丝5.png',      // 系列5
        '图片/莉莉丝22.png',      // 系列6
        '图片/莉莉丝7.png',      // 系列7
        '图片/莉莉丝8.png',      // 系列8
        '图片/莉莉丝10.png',     // 系列10
        '图片/莉莉丝11.png'      // 系列11
    ];
    
    // 创建容器
    sceneContainer.innerHTML = `
        <div class="glass-shatter-container">
            <!-- 环境光效 -->
            <div class="glass-ambient-light" style="width:500px;height:500px;top:10%;left:5%;"></div>
            <div class="glass-ambient-light" style="width:400px;height:400px;bottom:10%;right:10%;animation-delay:-1.5s;"></div>
            <div class="glass-ambient-light" style="width:350px;height:350px;top:50%;left:50%;transform:translate(-50%,-50%);animation-delay:-0.8s;"></div>
            
            <!-- 裂缝覆盖层 -->
            <div class="glass-crack-overlay" id="crackOverlay"></div>
            
            <!-- 3D空间 -->
            <div class="glass-3d-space" id="glass3dSpace"></div>
            
            <!-- 粒子层 -->
            <div id="glassParticles" style="position:absolute;inset:0;pointer-events:none;z-index:50;"></div>
            
            <!-- 特写层 - 独立于3D旋转空间 -->
            <div id="featureOverlay" style="position:absolute;inset:0;pointer-events:none;z-index:200;display:flex;justify-content:center;align-items:center;perspective:1000px;"></div>
        </div>
    `;
    
    const space3d = document.getElementById('glass3dSpace');
    const crackOverlay = document.getElementById('crackOverlay');
    const particlesContainer = document.getElementById('glassParticles');
    
    // 第一阶段：显示裂缝效果
    createCrackEffect(crackOverlay);
    createGlassParticles(particlesContainer);
    
    // 碎片数量
    const shardCount = 10;
    const shards = [];
    
    // 预计算每个碎片的最终位置（大幅增加分散范围）
    const finalPositions = [];
    for (let i = 0; i < shardCount; i++) {
        const angle = (i / shardCount) * Math.PI * 2 + (Math.random() - 0.5) * 0.5;
        // 大幅增加半径，让碎片分散更开
        const radius = 450 + Math.random() * 300;
        finalPositions.push({
            x: Math.cos(angle) * radius,
            y: (Math.random() - 0.5) * 600,
            z: Math.sin(angle) * radius * 0.4,
            rx: Math.random() * 30 - 15,
            ry: angle * (180 / Math.PI) + Math.random() * 30 - 15,
            rz: Math.random() * 20 - 10
        });
    }
    
    // 第二阶段：创建碎片并从中心爆炸扩散（所有碎片同时出现）
    setTimeout(() => {
        for (let i = 0; i < shardCount; i++) {
            const shard = document.createElement('div');
            shard.className = 'glass-shard';
            shard.dataset.index = i;
            
            const size = 130 + Math.random() * 70;
            const imgSrc = allAvailableImages[i];
            const fp = finalPositions[i];
            
            // 初始状态：在中心，缩小，透明
            shard.style.cssText = `
                --final-x: ${fp.x}px;
                --final-y: ${fp.y}px;
                --final-z: ${fp.z}px;
                --final-rx: ${fp.rx}deg;
                --final-ry: ${fp.ry}deg;
                --final-rz: ${fp.rz}deg;
                width: ${size}px;
                height: ${size * 1.3}px;
                transform: translate(-50%, -50%) scale(0.1) rotateZ(${Math.random() * 360}deg);
                opacity: 0;
                z-index: ${Math.floor(50 + Math.random() * 50)};
            `;
            
            // 创建3D玻璃碎片结构 - 图片在中间，正反面是透明玻璃
            shard.innerHTML = `
                <div class="glass-shard-inner">
                    <!-- 玻璃发光边框 -->
                    <div class="glass-glow"></div>
                    
                    <!-- 中间的图片层 -->
                    <div class="glass-image-center">
                        <img src="${imgSrc}" alt="">
                    </div>
                    
                    <!-- 玻璃正面（透明） -->
                    <div class="glass-face-front"></div>
                    
                    <!-- 玻璃背面（透明） -->
                    <div class="glass-face-back"></div>
                    
                    <!-- 玻璃边缘厚度 -->
                    <div class="glass-edge glass-edge-top"></div>
                    <div class="glass-edge glass-edge-bottom"></div>
                    <div class="glass-edge glass-edge-left"></div>
                    <div class="glass-edge glass-edge-right"></div>
                </div>
            `;
            
            space3d.appendChild(shard);
            shards.push(shard);
        }
        
        // 所有碎片同时显示并扩散
        requestAnimationFrame(() => {
            shards.forEach((shard, i) => {
                const fp = finalPositions[i];
                
                // 先显示
                shard.style.transition = 'opacity 0.3s ease';
                shard.style.opacity = '1';
                
                // 然后扩散到最终位置
                setTimeout(() => {
                    shard.style.transition = 'transform 1.5s cubic-bezier(0.22, 1, 0.36, 1)';
                    shard.style.transform = `
                        translate(-50%, -50%) 
                        translateX(${fp.x}px) 
                        translateY(${fp.y}px) 
                        translateZ(${fp.z}px)
                        rotateX(${fp.rx}deg) 
                        rotateY(${fp.ry}deg) 
                        rotateZ(${fp.rz}deg)
                        scale(1)
                    `;
                }, 50);
                
                // 开始浮动动画 - 使用JS实现，保持3D厚度
                setTimeout(() => {
                    shard.style.transition = 'transform 2s ease-in-out';
                    let floatPhase = Math.random() * 100; // 随机初始相位，让浮动不同步
                    shard.floatPhase = floatPhase;
                    shard.finalPos = fp;
                    const floatInterval = setInterval(() => {
                        // 如果正在特写，跳过浮动更新
                        if (shard.classList.contains('featured')) return;
                        
                        shard.floatPhase += 1;
                        const offsetY = Math.sin(shard.floatPhase * 0.05) * 25;
                        const offsetZ = Math.cos(shard.floatPhase * 0.03) * 30;
                        const rotX = fp.rx + Math.sin(shard.floatPhase * 0.04) * 8;
                        const rotY = fp.ry + shard.floatPhase * 0.3;
                        const rotZ = fp.rz + Math.cos(shard.floatPhase * 0.05) * 5;
                        
                        shard.style.transform = `
                            translate(-50%, -50%) 
                            translateX(${fp.x}px) 
                            translateY(${fp.y + offsetY}px) 
                            translateZ(${fp.z + offsetZ}px)
                            rotateX(${rotX}deg) 
                            rotateY(${rotY}deg) 
                            rotateZ(${rotZ}deg)
                            scale(1)
                        `;
                    }, 50);
                    sequenceIntervals.push(floatInterval);
                }, 1600);
            });
        });
        
        // 第三阶段：特写动画 - 在固定时间点进行三次特写
        // 场景3从16秒开始，特写时间点：18.1s, 18.6s, 19.1s（场景内2.1s, 2.6s, 3.1s）
        const featureTimes = [2100, 2600, 3100]; // 场景内时间（毫秒）
        const transitionTime = 100; // 切换时间0.1秒
        
        // 特写碎片的统一最终尺寸（宽度）
        const featureFinalWidth = 600;
        
        // 三个碎片的最终位置：左(1/6)、中(1/2)、右(5/6)
        const finalPositionsX = [
            window.innerWidth / 2,      // 第1个：屏幕中心
            window.innerWidth / 6,      // 第2个：屏幕左侧1/6
            window.innerWidth * 5 / 6   // 第3个：屏幕右侧5/6
        ];
        
        // 随机选择3个不同的碎片进行特写
        const shuffledIndices = [...Array(shards.length).keys()].sort(() => Math.random() - 0.5);
        const featureIndices = shuffledIndices.slice(0, 3);
        
        const featureOverlay = document.getElementById('featureOverlay');
        
        featureTimes.forEach((time, idx) => {
            setTimeout(() => {
                const shard = shards[featureIndices[idx]];
                const fp = shard.finalPos;
                
                // 获取碎片在屏幕上的位置和当前尺寸
                const rect = shard.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const screenCenterY = window.innerHeight / 2;
                
                // 获取碎片的原始宽度（不含缩放）
                const originalWidth = parseFloat(shard.style.width);
                // 计算需要的缩放比例，使最终宽度统一
                const targetScale = featureFinalWidth / originalWidth;
                
                // 该碎片的最终X位置
                const targetX = finalPositionsX[idx];
                
                // 从3D空间移出，放到特写层
                shard.classList.add('featured');
                
                // 移动到特写层，保持当前屏幕位置
                featureOverlay.appendChild(shard);
                shard.style.position = 'absolute';
                shard.style.left = centerX + 'px';
                shard.style.top = centerY + 'px';
                shard.style.transform = 'translate(-50%, -50%)';
                shard.style.zIndex = 500 + idx;
                
                // 椭圆曲线运动到目标位置
                requestAnimationFrame(() => {
                    const startX = centerX;
                    const startY = centerY;
                    const endX = targetX;
                    const endY = screenCenterY;
                    
                    // 根据碎片位置决定走左侧还是右侧的弧线
                    const goLeft = startX > endX;
                    
                    // 动画帧数和时间
                    const frames = Math.ceil(transitionTime / 16.67); // 约60fps
                    let frame = 0;
                    
                    // 禁用CSS transition，使用JS动画
                    shard.style.transition = 'transform 0.1s ease-out';
                    
                    // 曲线强度
                    const curveStrength = window.innerWidth * 0.2;
                    
                    const animateEllipse = () => {
                        frame++;
                        const progress = frame / frames;
                        // 使用缓动函数
                        const easeProgress = 1 - Math.pow(1 - progress, 3);
                        
                        // 线性插值位置
                        const linearX = startX + (endX - startX) * easeProgress;
                        const linearY = startY + (endY - startY) * easeProgress;
                        
                        // 使用椭圆偏移量叠加到线性路径上
                        const curveOffset = Math.sin(easeProgress * Math.PI); // 0→1→0 的曲线
                        const offsetX = (goLeft ? -1 : 1) * curveStrength * curveOffset;
                        
                        const currentX = linearX + offsetX;
                        const currentY = linearY;
                        
                        // 缩放和旋转插值（使用计算出的目标缩放比例）
                        const currentScale = 1 + (targetScale - 1) * easeProgress;
                        const currentRotX = (1 - easeProgress) * 30;
                        const currentRotY = (1 - easeProgress) * (goLeft ? -60 : 60);
                        const currentRotZ = (1 - easeProgress) * 15;
                        
                        shard.style.left = currentX + 'px';
                        shard.style.top = currentY + 'px';
                        shard.style.transform = `
                            translate(-50%, -50%) 
                            rotateX(${currentRotX}deg) 
                            rotateY(${currentRotY}deg) 
                            rotateZ(${currentRotZ}deg)
                            scale(${currentScale})
                        `;
                        
                        if (frame < frames) {
                            requestAnimationFrame(animateEllipse);
                        } else {
                            // 确保最终位置准确，碎片留在特写位置不返回
                            shard.style.left = endX + 'px';
                            shard.style.top = endY + 'px';
                            shard.style.transform = `
                                translate(-50%, -50%) 
                                rotateX(0deg) 
                                rotateY(0deg) 
                                rotateZ(0deg)
                                scale(${targetScale})
                            `;
                        }
                    };
                    
                    animateEllipse();
                });
                
                // 碎片留在特写位置，不再返回3D空间
            }, time);
        });
        
    }, 300);
}

// 创建裂缝效果
function createCrackEffect(container) {
    // 从中心向外的裂缝线
    const crackCount = 12;
    for (let i = 0; i < crackCount; i++) {
        const crack = document.createElement('div');
        crack.className = 'crack-line';
        const angle = (i / crackCount) * 360;
        const length = 100 + Math.random() * 400;
        crack.style.cssText = `
            top: 50%;
            left: 50%;
            width: ${length}px;
            transform: translate(-50%, -50%) rotate(${angle}deg);
            animation: glassCrackAppear 0.4s ease forwards;
            animation-delay: ${i * 0.02}s;
        `;
        container.appendChild(crack);
    }
    
    // 添加中心爆发点
    const burst = document.createElement('div');
    burst.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        width: 100px;
        height: 100px;
        transform: translate(-50%, -50%);
        background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(196,30,58,0.5) 50%, transparent 70%);
        border-radius: 50%;
        animation: glassCrackAppear 0.3s ease forwards;
    `;
    container.appendChild(burst);
}

// 创建玻璃粒子
function createGlassParticles(container) {
    for (let i = 0; i < 50; i++) {
        const particle = document.createElement('div');
        particle.className = 'glass-particle';
        const size = 2 + Math.random() * 6;
        const px = (Math.random() - 0.5) * window.innerWidth;
        const py = (Math.random() - 0.5) * window.innerHeight;
        const pr = Math.random() * 720 - 360;
        const duration = 1 + Math.random() * 1.5;
        const delay = Math.random() * 0.3;
        
        particle.style.cssText = `
            width: ${size}px;
            height: ${size}px;
            top: 50%;
            left: 50%;
            --px: ${px}px;
            --py: ${py}px;
            --pr: ${pr}deg;
            animation: glassParticleFly ${duration}s ease-out ${delay}s forwards;
        `;
        container.appendChild(particle);
    }
}

function renderExpressionLoop(images) {
    // 场景5：大师级运镜 - 使用莉莉丝22.png
    const imageToUse = '图片/莉莉丝22.png';
    
    sceneContainer.innerHTML = `
        <div class="main-canvas" style="background:#0a0a0a;">
            <!-- 装饰性背景 -->
            <div style="position:absolute;inset:0;background:radial-gradient(ellipse at center,rgba(196,30,58,0.08) 0%,transparent 50%);pointer-events:none;"></div>
            <div style="position:absolute;inset:0;background:repeating-linear-gradient(45deg,transparent,transparent 100px,rgba(196,30,58,0.02) 100px,rgba(196,30,58,0.02) 200px);pointer-events:none;"></div>
            
            <!-- 摄像机容器 -->
            <div id="scene5Camera" style="position:absolute;width:100%;height:100%;transform-origin:center center;">
                <!-- 画框容器 -->
                <div class="pv-image" style="width:100vw;height:100vh;animation:imgCircleReveal 1s ease forwards;display:flex;align-items:flex-start;justify-content:center;padding-top:0;">
                    <!-- 外层画框装饰 -->
                    <div style="position:relative;padding:12px;background:linear-gradient(135deg,#2a1a18 0%,#1a0a08 50%,#2a1a18 100%);box-shadow:0 0 60px rgba(0,0,0,0.8),inset 0 0 20px rgba(0,0,0,0.5);">
                        <!-- 画框边框 -->
                        <div style="position:absolute;inset:0;border:3px solid #3a2a28;pointer-events:none;"></div>
                        <div style="position:absolute;inset:6px;border:1px solid rgba(196,30,58,0.4);pointer-events:none;"></div>
                        <!-- 画框角落装饰 -->
                        <div style="position:absolute;top:8px;left:8px;width:20px;height:20px;border-left:2px solid #c41e3a;border-top:2px solid #c41e3a;"></div>
                        <div style="position:absolute;top:8px;right:8px;width:20px;height:20px;border-right:2px solid #c41e3a;border-top:2px solid #c41e3a;"></div>
                        <div style="position:absolute;bottom:8px;left:8px;width:20px;height:20px;border-left:2px solid #c41e3a;border-bottom:2px solid #c41e3a;"></div>
                        <div style="position:absolute;bottom:8px;right:8px;width:20px;height:20px;border-right:2px solid #c41e3a;border-bottom:2px solid #c41e3a;"></div>
                        <!-- 图片 -->
                        <img src="${imageToUse}" style="max-width:85vw;max-height:85vh;object-fit:contain;filter:contrast(1.15);display:block;">
                    </div>
                </div>
            </div>
            <div style="position:absolute;inset:0;background:radial-gradient(ellipse at center,transparent 40%,rgba(0,0,0,0.6) 100%);pointer-events:none;"></div>
        </div>
    `;
    
    // 大师级摄像机运动动画
    const camera = document.getElementById('scene5Camera');
    if (camera) {
        // 定义关键帧位置
        // 第一阶段起点
        const p1Start = { scale: 1.4, x: 20, y: -15, rotate: 2 };
        // 第一阶段终点 = 第二阶段起点（确保连续）
        const p1End = { scale: 1.8, x: -10, y: -10, rotate: -1 };
        // 第二阶段终点：图片左右居中、向上移动、摆正，保持放大
        const p2End = { scale: 5.1, x: 5, y: 30, rotate: 0 };
        
        camera.style.transform = `scale(${p1Start.scale}) translate(${p1Start.x}%, ${p1Start.y}%) rotate(${p1Start.rotate}deg)`;
        
        const startTime = performance.now();
        
        const animate = (currentTime) => {
            const elapsed = (currentTime - startTime) / 1000;
            
            // 使用统一的5秒总时长进行平滑插值
            const totalDuration = 5;
            const globalProgress = Math.min(elapsed / totalDuration, 1);
            
            // 使用三次贝塞尔曲线实现全程平滑过渡
            // 这个缓动函数在中间点（第一阶段结束/第二阶段开始）速度不为0
            const smoothEase = (t) => {
                // 平滑的S曲线，中间速度最快
                return t * t * (3 - 2 * t);
            };
            
            if (elapsed < totalDuration) {
                const easeProgress = smoothEase(globalProgress);
                
                // 使用二次贝塞尔曲线定义运动路径，确保平滑连续
                // 控制点设置在p1End附近，但稍微偏移以创造自然的曲线
                const controlPoint = {
                    scale: p1End.scale + 0.1,
                    x: p1End.x - 5,
                    y: p1End.y + 10,
                    rotate: p1End.rotate - 1
                };
                
                // 二次贝塞尔插值: B(t) = (1-t)²P0 + 2(1-t)tP1 + t²P2
                const t = easeProgress;
                const t1 = 1 - t;
                
                const scale = t1 * t1 * p1Start.scale + 2 * t1 * t * controlPoint.scale + t * t * p2End.scale;
                const translateX = t1 * t1 * p1Start.x + 2 * t1 * t * controlPoint.x + t * t * p2End.x;
                const translateY = t1 * t1 * p1Start.y + 2 * t1 * t * controlPoint.y + t * t * p2End.y;
                const rotate = t1 * t1 * p1Start.rotate + 2 * t1 * t * controlPoint.rotate + t * t * p2End.rotate;
                
                // 添加微弱的螺旋效果（从中段开始，逐渐增强再减弱）
                const spiralIntensity = Math.sin(globalProgress * Math.PI) * 3; // 中间最强
                const spiralAngle = globalProgress * Math.PI * 2;
                const spiralX = Math.sin(spiralAngle) * spiralIntensity;
                const spiralY = Math.cos(spiralAngle) * spiralIntensity * 0.5;
                
                camera.style.transform = `scale(${scale}) translate(${translateX + spiralX}%, ${translateY + spiralY}%) rotate(${rotate}deg)`;
                
                requestAnimationFrame(animate);
            } else {
                // 动画结束后保持稳定
                camera.style.transform = `scale(${p2End.scale}) translate(${p2End.x}%, ${p2End.y}%) rotate(${p2End.rotate}deg)`;
                
                requestAnimationFrame(animate);
            }
        };
        
        requestAnimationFrame(animate);
    }
}

function renderSingleDramatic(images) {
    sceneContainer.innerHTML = `
        <div class="main-canvas" style="background:#0a0a0a;">
            <!-- 装饰性背景 -->
            <div style="position:absolute;inset:0;background:radial-gradient(ellipse at center,rgba(196,30,58,0.08) 0%,transparent 50%);pointer-events:none;"></div>
            <div style="position:absolute;inset:0;background:repeating-linear-gradient(45deg,transparent,transparent 100px,rgba(196,30,58,0.02) 100px,rgba(196,30,58,0.02) 200px);pointer-events:none;"></div>
            
            <!-- 摄像机容器 -->
            <div id="scene4Camera" style="position:absolute;width:100%;height:100%;transform-origin:left top;">
                <div class="pv-image" style="width:100vw;height:100vh;animation:imgDiagonalReveal 1s ease forwards;display:flex;align-items:center;justify-content:center;">
                    <!-- 画框容器 - 图片在内部，画框边框在图片外围 -->
                    <div style="position:relative;padding:15px;background:linear-gradient(135deg,#2a1a18 0%,#1a0a08 50%,#2a1a18 100%);box-shadow:0 0 60px rgba(0,0,0,0.8),inset 0 0 20px rgba(0,0,0,0.5);">
                        <!-- 画框外边框 -->
                        <div style="position:absolute;inset:0;border:4px solid #3a2a28;pointer-events:none;"></div>
                        <!-- 画框内边框 -->
                        <div style="position:absolute;inset:6px;border:2px solid rgba(196,30,58,0.5);pointer-events:none;"></div>
                        <!-- 画框角落装饰 -->
                        <div style="position:absolute;top:10px;left:10px;width:25px;height:25px;border-left:3px solid #c41e3a;border-top:3px solid #c41e3a;"></div>
                        <div style="position:absolute;top:10px;right:10px;width:25px;height:25px;border-right:3px solid #c41e3a;border-top:3px solid #c41e3a;"></div>
                        <div style="position:absolute;bottom:10px;left:10px;width:25px;height:25px;border-left:3px solid #c41e3a;border-bottom:3px solid #c41e3a;"></div>
                        <div style="position:absolute;bottom:10px;right:10px;width:25px;height:25px;border-right:3px solid #c41e3a;border-bottom:3px solid #c41e3a;"></div>
                        <!-- 图片 - 尺寸略小于全屏，让画框边框可见 -->
                        <img src="${images[0]}" style="width:calc(100vw - 60px);height:calc(100vh - 60px);object-fit:cover;filter:contrast(1.2);display:block;">
                    </div>
                </div>
            </div>
            <div style="position:absolute;inset:0;background:radial-gradient(ellipse at center,transparent 30%,rgba(0,0,0,0.7) 100%);pointer-events:none;"></div>
        </div>
    `;
    
    // 摄像机运动动画 - 使用三次贝塞尔曲线确保全程平滑可导
    const camera = document.getElementById('scene4Camera');
    if (camera) {
        const startTime = performance.now();
        const duration = 6000; // 整个场景6秒
        
        // 四个控制点（三次贝塞尔曲线）
        const p0 = { scale: 1.6, x: -2, y: -20, rotate: 0 };      // 起点：左上角
        const p1 = { scale: 1.65, x: -5, y: -2, rotate: 0.5 };  // 控制点1：微微向右下漂移
        const p2 = { scale: 1.63, x: 10, y: -5, rotate: -0.3 }; // 控制点2：开始向右移动
        const p3 = { scale: 1.85, x: -40, y: -8, rotate: 0 };  // 终点：显示右侧
        
        // 三次贝塞尔插值函数
        const cubicBezier = (t, p0, p1, p2, p3) => {
            const t2 = t * t, t3 = t2 * t;
            const mt = 1 - t, mt2 = mt * mt, mt3 = mt2 * mt;
            return mt3 * p0 + 3 * mt2 * t * p1 + 3 * mt * t2 * p2 + t3 * p3;
        };
        
        // 平滑的S曲线缓动
        const smoothEase = (t) => {
            return t * t * (3 - 2 * t); // smoothstep
        };
        
        const animate = (now) => {
            const elapsed = now - startTime;
            const rawT = Math.min(elapsed / duration, 1);
            const t = smoothEase(rawT); // 应用平滑缓动
            
            const scale = cubicBezier(t, p0.scale, p1.scale, p2.scale, p3.scale);
            const x = cubicBezier(t, p0.x, p1.x, p2.x, p3.x);
            const y = cubicBezier(t, p0.y, p1.y, p2.y, p3.y);
            const rotate = cubicBezier(t, p0.rotate, p1.rotate, p2.rotate, p3.rotate);
            
            camera.style.transform = `scale(${scale}) translate(${x}%, ${y}%) rotate(${rotate}deg)`;
            
            if (rawT < 1) {
                requestAnimationFrame(animate);
            }
        };
        
        requestAnimationFrame(animate);
    }
}

function renderSplitMorph(images) {
    sceneContainer.innerHTML = `<div class="main-canvas" style="gap:0;"><div class="pv-image" style="width:55vw;height:100vh;clip-path:polygon(0 0,100% 0,70% 100%,0 100%);animation:imgSlideLeft 0.8s ease forwards;"><img id="splitL" src="${images[0]}" style="animation:imgKenBurns 8s ease-in-out infinite alternate;"></div><div class="pv-image" style="width:55vw;height:100vh;margin-left:-10vw;clip-path:polygon(30% 0,100% 0,100% 100%,0 100%);animation:imgSlideRight 0.8s ease 0.2s both;"><img id="splitR" src="${images[1]||images[0]}" style="animation:imgKenBurns 8s ease-in-out infinite alternate-reverse;"></div></div>`;
    if (images.length > 2) { let idx = 0; const iv = setInterval(() => { idx = (idx + 1) % (images.length - 1); const t = idx % 2 === 0 ? 'splitL' : 'splitR'; const img = document.getElementById(t); if (img) { img.src = images[idx + 1]; img.style.animation = 'none'; img.offsetHeight; img.style.animation = 'seqPulse 0.3s ease, imgKenBurns 8s ease-in-out infinite alternate'; } }, 500); sequenceIntervals.push(iv); }
}

function renderQuadGrid(images) {
    // 场景7：5秒内依次显示4张图，每张1.25秒
    // 按图片命名顺序显示（莉莉丝6.png, 莉莉丝6-1.png, 莉莉丝6-2.png, 莉莉丝6-3.png）
    let idx = 0;
    
    // 固定的入场和持续动画
    const enterAnims = ['imgSlideLeft', 'imgSlideRight', 'imgSlideUp', 'imgZoomIn'];
    const showAnims = ['imgFloat', 'imgPulse', 'imgSway', 'imgBreath'];
    
    sceneContainer.innerHTML = `
        <div class="main-canvas" style="background:#000;">
            <div class="pv-image border-thin shadow-red" style="width:85vw;height:85vh;animation:${enterAnims[0]} 0.5s ease forwards;">
                <img id="quadImg" src="${images[0]}" style="width:100%;height:100%;object-fit:cover;animation:${showAnims[0]} 1.5s ease-in-out infinite;">
            </div>
            <div id="quadFlash" style="position:absolute;inset:0;background:#fff;opacity:0;pointer-events:none;z-index:10;"></div>
        </div>
    `;
    
    if (images.length > 1) {
        const switchTime = 1250; // 1.25秒切换一次
        const iv = setInterval(() => {
            idx++;
            if (idx >= 4 || idx >= images.length) {
                clearInterval(iv);
                return;
            }
            
            const img = document.getElementById('quadImg');
            const flash = document.getElementById('quadFlash');
            const container = img?.parentElement;
            
            if (img && flash && container) {
                // 闪白效果
                flash.style.transition = 'opacity 0.06s ease';
                flash.style.opacity = '1';
                
                setTimeout(() => {
                    // 切换图片和动画
                    img.src = images[idx];
                    container.style.animation = 'none';
                    container.offsetHeight;
                    container.style.animation = `${enterAnims[idx]} 0.5s ease forwards`;
                    img.style.animation = `${showAnims[idx]} 1.5s ease-in-out infinite`;
                    
                    // 闪白消失
                    flash.style.transition = 'opacity 0.12s ease';
                    flash.style.opacity = '0';
                }, 60);
            }
        }, switchTime);
        sequenceIntervals.push(iv);
    }
}

function renderWhisperFloat(images) {
    // 场景8：莉莉丝1系列，先显示莉莉丝1.png，43.5秒叠化切换到莉莉丝1-1.png
    // 场景开始于41秒，所以延迟2.5秒切换
    const img1 = '图片/莉莉丝1.png';
    const img2 = '图片/莉莉丝1-1.png';
    
    sceneContainer.innerHTML = `
        <div class="main-canvas">
            <!-- 第一张图片（底层） -->
            <div id="whisperImg1" class="pv-image" style="position:absolute;width:100vw;height:100vh;animation:imgZoomIn 1s ease forwards;z-index:1;">
                <img src="${img1}" style="width:100%;height:100%;object-fit:cover;animation:imgFloat 4s ease-in-out infinite;filter:contrast(1.15);">
            </div>
            <!-- 第二张图片（顶层，初始透明） -->
            <div id="whisperImg2" class="pv-image" style="position:absolute;width:100vw;height:100vh;opacity:0;z-index:2;">
                <img src="${img2}" style="width:100%;height:100%;object-fit:cover;animation:imgFloat 4s ease-in-out infinite;filter:contrast(1.15);">
            </div>
            <div style="position:absolute;inset:0;background:radial-gradient(ellipse at center,transparent 35%,rgba(0,0,0,0.7) 100%);z-index:3;pointer-events:none;"></div>
        </div>
    `;
    
    // 2.5秒后叠化切换到第二张图片
    setTimeout(() => {
        const img2El = document.getElementById('whisperImg2');
        if (img2El) {
            // 叠化效果：第二张淡入覆盖第一张
            img2El.style.transition = 'opacity 1s ease';
            img2El.style.opacity = '1';
        }
    }, 2500);
}

function renderTulpaDuality(images) {
    // 场景9：莉莉丝8系列，先显示莉莉丝8-4.png，49.2秒故障切换到莉莉丝8.png
    // 场景开始于46秒，所以延迟3.2秒切换
    const img1 = '图片/莉莉丝8-4.png';
    const img2 = '图片/莉莉丝8.png';
    
    sceneContainer.innerHTML = `
        <div class="main-canvas" style="background:#0a0a0a;">
            <!-- 装饰性背景 - 青蓝色调 -->
            <div style="position:absolute;inset:0;background:radial-gradient(ellipse at center,rgba(88,166,196,0.06) 0%,transparent 50%);pointer-events:none;"></div>
            <div style="position:absolute;inset:0;background:repeating-linear-gradient(45deg,transparent,transparent 100px,rgba(88,166,196,0.02) 100px,rgba(88,166,196,0.02) 200px);pointer-events:none;"></div>
            
            <!-- 摄像机容器 -->
            <div id="scene9Camera" style="position:absolute;width:100%;height:100%;transform-origin:center center;">
                <!-- 第一张图片（底层） -->
                <div id="tulpaImg1" class="pv-image" style="position:absolute;width:100vw;height:100vh;z-index:1;">
                    <img src="${img1}" style="width:100%;height:100%;object-fit:cover;filter:contrast(1.2) saturate(1.1);">
                </div>
                <!-- 第二张图片（顶层，初始透明） -->
                <div id="tulpaImg2" class="pv-image" style="position:absolute;width:100vw;height:100vh;opacity:0;z-index:2;">
                    <img src="${img2}" style="width:100%;height:100%;object-fit:cover;filter:contrast(1.2) saturate(1.1);">
                </div>
            </div>
            <!-- 故障遮罩层 -->
            <div id="tulpaGlitchMask" style="position:absolute;inset:0;z-index:4;pointer-events:none;opacity:0;overflow:hidden;"></div>
            <div style="position:absolute;inset:0;background:radial-gradient(ellipse at center,transparent 35%,rgba(0,0,0,0.65) 100%);z-index:5;pointer-events:none;"></div>
        </div>
    `;
    
    // 大师级摄像机运动动画（参考场景5）
    const camera = document.getElementById('scene9Camera');
    if (camera) {
        // 定义关键帧位置 - 6秒时长，使用三次贝塞尔曲线（4个点）
        const p0 = { scale: 2, x: -15, y: 10, rotate: -2 };           // 起点
        const p1 = { scale: 1.6, x: 10, y: -43, rotate: 1 };          // 控制点1
        const p2 = { scale: 1, x: 0, y: 0, rotate: 0 };           // 控制点2（新增）
        const p3 = { scale: 1.4, x: 0, y: 14, rotate: 0 };            // 终点
        
        camera.style.transform = `scale(${p0.scale}) translate(${p0.x}%, ${p0.y}%) rotate(${p0.rotate}deg)`;
        
        const startTime = performance.now();
        
        const animate = (currentTime) => {
            const elapsed = (currentTime - startTime) / 1000;
            const totalDuration = 6; // 6秒
            const globalProgress = Math.min(elapsed / totalDuration, 1);
            
            // 平滑S曲线
            const smoothEase = (t) => t * t * (3 - 2 * t);
            
            if (elapsed < totalDuration) {
                const t = smoothEase(globalProgress);
                
                // 三次贝塞尔插值: B(t) = (1-t)³P0 + 3(1-t)²tP1 + 3(1-t)t²P2 + t³P3
                const t1 = 1 - t;
                const t1_3 = t1 * t1 * t1;
                const t1_2_t = 3 * t1 * t1 * t;
                const t1_t_2 = 3 * t1 * t * t;
                const t_3 = t * t * t;
                
                const scale = t1_3 * p0.scale + t1_2_t * p1.scale + t1_t_2 * p2.scale + t_3 * p3.scale;
                const translateX = t1_3 * p0.x + t1_2_t * p1.x + t1_t_2 * p2.x + t_3 * p3.x;
                const translateY = t1_3 * p0.y + t1_2_t * p1.y + t1_t_2 * p2.y + t_3 * p3.y;
                const rotate = t1_3 * p0.rotate + t1_2_t * p1.rotate + t1_t_2 * p2.rotate + t_3 * p3.rotate;
                
                // 微弱螺旋效果
                const spiralIntensity = Math.sin(globalProgress * Math.PI) * 2;
                const spiralAngle = globalProgress * Math.PI * 1.5;
                const spiralX = Math.sin(spiralAngle) * spiralIntensity;
                const spiralY = Math.cos(spiralAngle) * spiralIntensity * 0.5;
                
                camera.style.transform = `scale(${scale}) translate(${translateX + spiralX}%, ${translateY + spiralY}%) rotate(${rotate}deg)`;
                
                requestAnimationFrame(animate);
            } else {
                camera.style.transform = `scale(${p3.scale}) translate(${p3.x}%, ${p3.y}%) rotate(${p3.rotate}deg)`;
            }
        };
        
        requestAnimationFrame(animate);
    }
    
    // 3.2秒后故障切换到第二张图片
    setTimeout(() => {
        const img1El = document.getElementById('tulpaImg1');
        const img2El = document.getElementById('tulpaImg2');
        const glitchMask = document.getElementById('tulpaGlitchMask');
        const camera = document.getElementById('scene9Camera');
        
        if (img1El && img2El && glitchMask) {
            // 增强版电视信号故障效果
            let glitchHTML = '';
            
            // 1. 强烈RGB色彩分离（多层）
            glitchHTML += `
                <div style="position:absolute;inset:0;background:rgba(255,0,0,0.4);transform:translateX(-12px) translateY(3px);animation:tulpaCRT_RGB_Strong 0.6s ease forwards;mix-blend-mode:screen;"></div>
                <div style="position:absolute;inset:0;background:rgba(0,255,255,0.4);transform:translateX(12px) translateY(-3px);animation:tulpaCRT_RGB_Strong 0.6s ease forwards;mix-blend-mode:screen;"></div>
                <div style="position:absolute;inset:0;background:rgba(0,255,0,0.2);transform:translateY(6px);animation:tulpaCRT_RGB_Strong 0.6s ease 0.1s forwards;mix-blend-mode:screen;"></div>
            `;
            
            // 2. 更多水平撕裂条（画面错位）
            for (let i = 0; i < 8; i++) {
                const top = 8 + i * 12;
                const offset = (i % 2 === 0 ? 1 : -1) * (20 + Math.random() * 40);
                const height = 5 + Math.random() * 10;
                glitchHTML += `
                    <div style="position:absolute;top:${top}%;left:0;width:100%;height:${height}%;background:linear-gradient(90deg, rgba(0,0,0,0.95) 0%, transparent 2%, transparent 98%, rgba(0,0,0,0.95) 100%);transform:translateX(${offset}px);animation:tulpaTearSlice_Strong 0.5s ease ${i*0.03}s forwards;"></div>
                `;
            }
            
            // 3. 数据块损坏效果（马赛克块）
            for (let i = 0; i < 12; i++) {
                const x = Math.random() * 90;
                const y = Math.random() * 90;
                const w = 5 + Math.random() * 15;
                const h = 3 + Math.random() * 8;
                const color = Math.random() > 0.5 ? 'rgba(255,0,100,0.8)' : 'rgba(0,200,255,0.8)';
                glitchHTML += `
                    <div style="position:absolute;left:${x}%;top:${y}%;width:${w}%;height:${h}%;background:${color};animation:tulpaBlockGlitch 0.4s steps(3) ${Math.random()*0.2}s forwards;"></div>
                `;
            }
            
            // 4. CRT扫描线（更密集）
            glitchHTML += `<div style="position:absolute;inset:0;background:repeating-linear-gradient(0deg, transparent 0px, transparent 1px, rgba(0,0,0,0.3) 1px, rgba(0,0,0,0.3) 2px);animation:tulpaCRT_Lines 0.6s ease forwards;"></div>`;
            
            // 5. 噪点层
            glitchHTML += `<div style="position:absolute;inset:0;background-image:url('data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 200 200%22><filter id=%22n%22><feTurbulence type=%22fractalNoise%22 baseFrequency=%220.9%22 numOctaves=%224%22/></filter><rect width=%22100%25%22 height=%22100%25%22 filter=%22url(%23n)%22 opacity=%220.3%22/></svg>');animation:tulpaNoise 0.5s steps(5) forwards;mix-blend-mode:overlay;"></div>`;
            
            // 6. 多次闪烁（更强烈）
            glitchHTML += `<div style="position:absolute;inset:0;background:#fff;animation:tulpaCRT_Flash_Strong 0.6s ease forwards;"></div>`;
            
            // 7. 黑屏闪烁
            glitchHTML += `<div style="position:absolute;inset:0;background:#000;animation:tulpaBlackout 0.6s steps(2) forwards;"></div>`;
            
            glitchMask.innerHTML = glitchHTML;
            glitchMask.style.opacity = '1';
            
            // 图片强烈抖动+色相偏移
            img1El.style.animation = 'tulpaCRT_Shake_Strong 0.5s ease forwards';
            img1El.querySelector('img').style.animation = 'tulpaHueShift 0.5s steps(4) forwards';
            
            // 摄像机也抖动
            if (camera) {
                camera.style.animation = 'tulpaCameraShake 0.4s ease';
            }
            
            // 0.25秒后切换图片
            setTimeout(() => {
                img2El.style.transition = 'opacity 0.1s ease';
                img2El.style.opacity = '1';
            }, 250);
            
            // 0.6秒后清除故障效果
            setTimeout(() => {
                glitchMask.style.transition = 'opacity 0.2s ease';
                glitchMask.style.opacity = '0';
                if (camera) {
                    camera.style.animation = '';
                }
            }, 600);
        }
    }, 3200);
}

function renderRapidSequence(images) {
    // 场景10：5秒内显示3张图，镜子依次裂开破碎的过程
    // 第一张：完整镜子
    // 第二张：镜子开始裂开
    // 第三张：镜子完全破碎
    let idx = 0;
    
    // 不同的Ken Burns运动方向
    const kenBurnsStyles = [
        'transform-origin: left top; animation: rapidKenBurns1 2s ease-in-out forwards;',
        'transform-origin: right bottom; animation: rapidKenBurns2 2s ease-in-out forwards;',
        'transform-origin: center; animation: rapidKenBurns3 2s ease-in-out forwards;'
    ];
    
    sceneContainer.innerHTML = `
        <div class="main-canvas" style="background:#000;">
            <div class="pv-image shadow-glow rapid-img-container" style="width:100vw;height:100vh;overflow:hidden;position:relative;">
                <img id="rapidImg" src="${images[0]}" style="width:100%;height:100%;object-fit:cover;filter:contrast(1.3);${kenBurnsStyles[0]}">
                <div id="mirrorCrack" style="position:absolute;inset:0;pointer-events:none;z-index:5;"></div>
            </div>
        </div>
    `;
    
    if (images.length > 1) {
        const switchTime = 1670; // 约1.67秒切换一次
        const iv = setInterval(() => {
            idx++;
            if (idx >= images.length) {
                clearInterval(iv);
                return;
            }
            
            const img = document.getElementById('rapidImg');
            const crackOverlay = document.getElementById('mirrorCrack');
            
            if (img && crackOverlay) {
                // 镜子裂开效果
                let crackHTML = '';
                
                if (idx === 1) {
                    // 第一次切换：镜子破碎（碎片飞散到屏幕边缘外）
                    for (let i = 0; i < 20; i++) {
                        const x = 30 + Math.random() * 40;
                        const y = 20 + Math.random() * 60;
                        const size = 3 + Math.random() * 8;
                        const angle = Math.random() * 360;
                        // 碎片从中心向四周爆炸飞散，飞到屏幕边缘外
                        const direction = Math.random() * Math.PI * 2;
                        const distance = 80 + Math.random() * 60;
                        const offsetX = Math.cos(direction) * distance;
                        const offsetY = Math.sin(direction) * distance;
                        crackHTML += `
                            <div style="position:absolute;left:${x}%;top:${y}%;width:${size}%;height:${size}%;background:rgba(255,255,255,0.4);border:1px solid rgba(255,255,255,0.7);transform:rotate(${angle}deg);animation:mirrorShatter 1.5s cubic-bezier(0.25,0.46,0.45,0.94) forwards;--offset-x:${offsetX}vw;--offset-y:${offsetY}vh;box-shadow:0 0 10px rgba(255,255,255,0.5);"></div>
                        `;
                    }
                    // 全屏白色闪光
                    crackHTML += `<div style="position:absolute;inset:0;background:#fff;animation:mirrorShatterFlash 0.5s ease forwards;"></div>`;
                    
                } else if (idx === 2) {
                    // 第二次切换：镜子完全破碎（碎片飞散到屏幕边缘外）
                    for (let i = 0; i < 20; i++) {
                        const x = 30 + Math.random() * 40;
                        const y = 20 + Math.random() * 60;
                        const size = 3 + Math.random() * 8;
                        const angle = Math.random() * 360;
                        // 碎片从中心向四周爆炸飞散，飞到屏幕边缘外
                        // 使用vw/vh单位确保飞出屏幕
                        const direction = Math.random() * Math.PI * 2; // 随机方向
                        const distance = 80 + Math.random() * 60; // 80-140vw的距离
                        const offsetX = Math.cos(direction) * distance;
                        const offsetY = Math.sin(direction) * distance;
                        crackHTML += `
                            <div style="position:absolute;left:${x}%;top:${y}%;width:${size}%;height:${size}%;background:rgba(255,255,255,0.4);border:1px solid rgba(255,255,255,0.7);transform:rotate(${angle}deg);animation:mirrorShatter 1.5s cubic-bezier(0.25,0.46,0.45,0.94) forwards;--offset-x:${offsetX}vw;--offset-y:${offsetY}vh;box-shadow:0 0 10px rgba(255,255,255,0.5);"></div>
                        `;
                    }
                    // 全屏白色闪光
                    crackHTML += `<div style="position:absolute;inset:0;background:#fff;animation:mirrorShatterFlash 0.5s ease forwards;"></div>`;
                }
                
                crackOverlay.innerHTML = crackHTML;
                
                // 图片抖动效果（临时覆盖Ken Burns）
                img.style.animation = 'mirrorShake 0.3s ease';
                
                // 延迟切换图片
                setTimeout(() => {
                    img.src = images[idx];
                    // 恢复Ken Burns运动
                    img.style.animation = 'none';
                    img.offsetHeight; // 触发重绘
                    img.style.cssText = `width:100%;height:100%;object-fit:cover;filter:contrast(1.3);${kenBurnsStyles[idx % kenBurnsStyles.length]}`;
                }, 150);
                
                // 清除裂纹效果
                setTimeout(() => {
                    if (idx < images.length - 1) {
                        crackOverlay.innerHTML = '';
                    }
                }, 800);
            }
        }, switchTime);
        sequenceIntervals.push(iv);
    }
}

function renderDanceMontage(images) {
    // 场景11：只用莉莉丝10-4（0:57-1:00，3秒）和莉莉丝10-3（1:00-1:02，2秒）
    // 两张图只有表情变化，使用柔和的叠化+涟漪效果
    const img1 = '图片/莉莉丝10-4.png';
    const img2 = '图片/莉莉丝10-3.png';
    
    sceneContainer.innerHTML = `
        <div class="main-canvas">
            <div class="pv-image border-thick shadow-glow" style="width:95vw;height:90vh;animation:imgZoomIn 0.8s ease forwards;position:relative;overflow:hidden;">
                <img id="montageImg1" src="${img1}" style="position:absolute;inset:0;width:100%;height:100%;object-fit:cover;animation:imgKenBurns 5s ease-in-out infinite alternate;filter:contrast(1.2);z-index:2;">
                <img id="montageImg2" src="${img2}" style="position:absolute;inset:0;width:100%;height:100%;object-fit:cover;animation:imgKenBurns2 5s ease-in-out infinite alternate;filter:contrast(1.2);opacity:0;z-index:1;">
                <div id="montageRipple" style="position:absolute;inset:0;pointer-events:none;z-index:10;"></div>
            </div>
        </div>
    `;
    
    // 3秒后切换到第二张图 - 涟漪叠化效果
    const iv = setTimeout(() => {
        const img1El = document.getElementById('montageImg1');
        const img2El = document.getElementById('montageImg2');
        const ripple = document.getElementById('montageRipple');
        
        if (img1El && img2El && ripple) {
            // 添加涟漪效果
            ripple.innerHTML = `
                <div style="position:absolute;top:50%;left:50%;width:0;height:0;border-radius:50%;background:radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);transform:translate(-50%,-50%);animation:montageRippleExpand 1.2s ease-out forwards;"></div>
                <div style="position:absolute;top:50%;left:50%;width:0;height:0;border-radius:50%;border:2px solid rgba(255,255,255,0.4);transform:translate(-50%,-50%);animation:montageRippleExpand 1.2s ease-out 0.15s forwards;"></div>
            `;
            
            // 第一张图柔和淡出
            img1El.style.transition = 'opacity 0.8s ease-in-out';
            img1El.style.opacity = '0';
            
            // 第二张图柔和淡入
            img2El.style.transition = 'opacity 0.8s ease-in-out';
            img2El.style.opacity = '1';
            
            // 清除涟漪
            setTimeout(() => {
                ripple.innerHTML = '';
            }, 1500);
        }
    }, 3000);
    sequenceIntervals.push(iv);
}

function renderWorldTearFinale(images) {
    // 场景12：全屏单图显示 + 三次贝塞尔曲线摄像机运动
    // 使用莉莉丝11系列的4张图：11.png, 11-1.png, 11-2.png, 11-3.png
    const img1 = '图片/莉莉丝11.png';
    const img2 = '图片/莉莉丝11-1.png';
    const img3 = '图片/莉莉丝11-2.png';
    const img4 = '图片/莉莉丝11-3.png';
    
    sceneContainer.innerHTML = `
        <div class="main-canvas" style="background:#000;">
            <div id="scene12Camera" style="width:100%;height:100%;transform-origin:center center;">
                <div class="pv-image" style="width:100vw;height:100vh;animation:worldTear 1.5s cubic-bezier(0.16,1,0.3,1) forwards;">
                    <img id="scene12Img" src="${img1}" style="width:100%;height:100%;object-fit:cover;filter:contrast(1.4) saturate(1.2);">
                </div>
            </div>
        </div>
    `;
    
    // 三次贝塞尔曲线摄像机运动（5秒）
    const camera = document.getElementById('scene12Camera');
    if (camera) {
        const startTime = performance.now();
        const duration = 5000;
        
        // 控制点
        const p0 = { scale: 1.8, x: -10, y: -15, rotate: -1 };
        const p1 = { scale: 1.5, x: 8, y: 5, rotate: 1 };
        const p2 = { scale: 1.3, x: -5, y: 10, rotate: -0.5 };
        const p3 = { scale: 1.6, x: 0, y: 18, rotate: 0 };
        
        const cubicBezier = (t, p0, p1, p2, p3) => {
            const t2 = t * t, t3 = t2 * t;
            const mt = 1 - t, mt2 = mt * mt, mt3 = mt2 * mt;
            return mt3 * p0 + 3 * mt2 * t * p1 + 3 * mt * t2 * p2 + t3 * p3;
        };
        
        const animate = (now) => {
            const elapsed = now - startTime;
            const t = Math.min(elapsed / duration, 1);
            
            const scale = cubicBezier(t, p0.scale, p1.scale, p2.scale, p3.scale);
            const x = cubicBezier(t, p0.x, p1.x, p2.x, p3.x);
            const y = cubicBezier(t, p0.y, p1.y, p2.y, p3.y);
            const rotate = cubicBezier(t, p0.rotate, p1.rotate, p2.rotate, p3.rotate);
            
            camera.style.transform = `scale(${scale}) translate(${x}%, ${y}%) rotate(${rotate}deg)`;
            
            if (t < 1) {
                requestAnimationFrame(animate);
            }
        };
        
        requestAnimationFrame(animate);
    }
    
    // 红色闪光效果 + 图片切换 + 图片抖动（间隔0.6秒）
    const imgEl = document.getElementById('scene12Img');
    const flashImages = [img2, img3, img4]; // 三次闪光对应的三张图
    
    setTimeout(() => { 
        for (let i = 0; i < 3; i++) {
            setTimeout(() => { 
                // 红色闪光
                transitionSystem.innerHTML = '<div style="position:absolute;inset:0;background:#c41e3a;animation:finalFlash 0.2s ease forwards;"></div>';
                
                // 图片强烈抖动
                if (imgEl) {
                    imgEl.style.animation = 'mirrorShake 0.3s ease';
                    
                    // 闪光后切换图片
                    setTimeout(() => {
                        imgEl.src = flashImages[i];
                        imgEl.style.animation = '';
                    }, 100);
                }
            }, i * 1300); // 间隔1.3秒
        }
    }, 1500);
}

function renderScene13(images) {
    // 场景13：全屏单图显示 + 三次贝塞尔曲线摄像机运动
    sceneContainer.innerHTML = `
        <div class="main-canvas" style="background:#0a0a0a;">
            <div id="scene13Camera" style="width:100%;height:100%;transform-origin:center center;">
                <div class="pv-image" style="width:100vw;height:100vh;animation:imgGlitchIn 0.8s ease forwards;">
                    <img src="${images[0]}" style="width:100%;height:100%;object-fit:cover;filter:contrast(1.2) brightness(1.1);">
                </div>
            </div>
            <div style="position:absolute;inset:0;background:radial-gradient(ellipse at center,transparent 30%,rgba(0,0,0,0.7) 100%);pointer-events:none;"></div>
        </div>
    `;
    
    // 三次贝塞尔曲线摄像机运动（5秒）
    const camera = document.getElementById('scene13Camera');
    if (camera) {
        const startTime = performance.now();
        const duration = 5000;
        
        // 控制点（与场景12不同的轨迹）
        const p0 = { scale: 1.6, x: 12, y: -8, rotate: 1.5 };
        const p1 = { scale: 1.4, x: -40, y: 30, rotate: -1 };
        const p2 = { scale: 1.2, x: 5, y: -5, rotate: 0.5 };
        const p3 = { scale: 1.1, x: 0, y: 5, rotate: 0 };
        
        const cubicBezier = (t, p0, p1, p2, p3) => {
            const t2 = t * t, t3 = t2 * t;
            const mt = 1 - t, mt2 = mt * mt, mt3 = mt2 * mt;
            return mt3 * p0 + 3 * mt2 * t * p1 + 3 * mt * t2 * p2 + t3 * p3;
        };
        
        const animate = (now) => {
            const elapsed = now - startTime;
            const t = Math.min(elapsed / duration, 1);
            
            const scale = cubicBezier(t, p0.scale, p1.scale, p2.scale, p3.scale);
            const x = cubicBezier(t, p0.x, p1.x, p2.x, p3.x);
            const y = cubicBezier(t, p0.y, p1.y, p2.y, p3.y);
            const rotate = cubicBezier(t, p0.rotate, p1.rotate, p2.rotate, p3.rotate);
            
            camera.style.transform = `scale(${scale}) translate(${x}%, ${y}%) rotate(${rotate}deg)`;
            
            if (t < 1) {
                requestAnimationFrame(animate);
            }
        };
        
        requestAnimationFrame(animate);
    }
}
</script>
<script>
// ==================== 转场到相册 ====================
function transitionToAlbum() {
    if (isAlbumMode) return;
    isAlbumMode = true;
    clearSequences();
    
    // 立即隐藏底部歌词
    lyricsContainer.classList.add('hidden');
    lyricCn.textContent = '';
    lyricJp.textContent = '';
    
    // 淡出场景（PV歌词保持显示，与场景一起模糊）
    sceneContainer.classList.add('fade-out');
    
    // PV歌词也添加模糊淡出效果
    const pvOverlay = document.getElementById('pvLyricOverlay');
    if (pvOverlay) {
        pvOverlay.style.transition = 'opacity 1.5s ease, filter 1.5s ease';
        pvOverlay.style.filter = 'blur(10px)';
        pvOverlay.style.opacity = '0';
    }
    
    setTimeout(() => { 
        transitionSystem.innerHTML = '<div style="position:absolute;inset:0;background:#fff;animation:finalFlash 1.5s ease forwards;"></div>'; 
    }, 500);
    
    setTimeout(() => { 
        // 清空场景内容，防止文字残留
        sceneContainer.innerHTML = ''; 
        sceneContainer.style.display = 'none';
        
        // 清除PV歌词
        if (pvOverlay) {
            pvOverlay.innerHTML = '';
            pvOverlay.style.filter = '';
            pvOverlay.style.opacity = '';
            pvOverlay.style.transition = '';
        }
        
        // 激活相册
        albumMode.classList.add('active'); 
        initAlbum(); 
    }, 1500);
}

/**
 * ========================================
 * 相册系统 - 核心模块
 * ========================================
 * 
 * 【整体结构】
 * 相册被设计成一本可翻阅的书：
 * 
 * ┌─────────────────────────────────────────────────────┐
 * │                    相册结构图                        │
 * ├─────────────────────────────────────────────────────┤
 * │                                                     │
 * │  【初始状态 - 封面关闭】                              │
 * │  ┌─────────────┐                                   │
 * │  │   A正面     │  ← 显示标题"不存在的你和我"         │
 * │  │  (封面)     │                                   │
 * │  └─────────────┘                                   │
 * │                                                     │
 * │  【打开封面后 - 第1页】                              │
 * │  ┌─────────────┬─────────────┐                     │
 * │  │   A反面     │   B1正面    │                     │
 * │  │  (暗红色)   │  (图1-4)    │                     │
 * │  └─────────────┴─────────────┘                     │
 * │                                                     │
 * │  【翻过B1后 - 第2页】                               │
 * │  ┌─────────────┬─────────────┐                     │
 * │  │   B1反面    │   B2正面    │                     │
 * │  │  (图5-8)    │  (图9-12)   │                     │
 * │  └─────────────┴─────────────┘                     │
 * │                                                     │
 * │  【翻过B2后 - 第3页】                               │
 * │  ┌─────────────┬─────────────┐                     │
 * │  │   B2反面    │   B3正面    │                     │
 * │  │  (图13-16)  │  (图17-20)  │                     │
 * │  └─────────────┴─────────────┘                     │
 * │                                                     │
 * │  【翻过B3后 - 最后一页】                            │
 * │  ┌─────────────┬─────────────┐                     │
 * │  │   B3反面    │   封底      │                     │
 * │  │  (图21-24)  │  (暗红色)   │                     │
 * │  └─────────────┴─────────────┘                     │
 * │                                                     │
 * └─────────────────────────────────────────────────────┘
 * 
 * 【页码说明】
 * - currentPageIndex = 0：显示 A反面 + B1正面
 * - currentPageIndex = 1：显示 B1反面 + B2正面
 * - currentPageIndex = 2：显示 B2反面 + B3正面
 * - currentPageIndex = 3：显示 B3反面 + 封底
 * 
 * 【翻页原理】
 * 每个内页(B1/B2/B3)都是一个可翻转的DOM元素：
 * - 未翻转时：正面显示在右侧
 * - 翻转后(添加flipped类)：反面显示在左侧
 * - 翻转动画：绕左边缘旋转180度
 */
let albumInitialized = false;

/**
 * 初始化相册
 * 只在第一次进入相册模式时执行完整初始化
 * 之后再进入只需要重置状态
 */
function initAlbum() {
    // 防止重复初始化（比如用户多次跳转到相册时间点）
    if (albumInitialized) {
        resetAlbum();
        return;
    }
    albumInitialized = true;
    
    // 计算内页数量
    // 图片部分：B1正面是扉页，B1反面开始显示图片
    // 24张图需要6个面（每面4张），加上1个扉页面，共7个面
    // 7个面需要4页（B1正反面 + B2正反面 + B3正反面 + B4正面）
    // 但实际上我们在createFlippablePages中会重新计算
    totalInnerPages = 0;  // 会在createFlippablePages中设置
    currentPageIndex = 0;  // 从第0页开始（打开封面后显示的第一页）
    isCoverOpen = false;   // 封面初始是关闭的
    
    // 创建所有可翻动的内页（B1, B2, B3, B4 + 视频页）
    createFlippablePages();
    
    // 创建最后一页底层（封底，当所有内页翻完后显示在右侧）
    createLastPage();
    
    // 初始化显示状态
    updatePageDisplay();
    updateNavigation();
    
    // 绑定事件：点击封面打开相册
    bookCover.addEventListener('click', openCover);
    
    // 绑定导航按钮事件
    document.getElementById('prevPage').addEventListener('click', goPrevPage);
    document.getElementById('nextPage').addEventListener('click', goNextPage);
    
    // 绑定图片查看器事件
    document.getElementById('viewerClose').addEventListener('click', closeViewer);
    viewerImage.addEventListener('click', nextViewerImage);
    viewer.querySelector('.viewer-backdrop').addEventListener('click', closeViewer);
    
    // 绑定视频播放器事件 - B站嵌入
    document.getElementById('videoCloseBtn').addEventListener('click', closeVideoPlayer);
    document.getElementById('videoPlayerModal').addEventListener('click', (e) => {
        if (e.target.id === 'videoPlayerModal') closeVideoPlayer();
    });
    
    // 绑定键盘事件（方向键翻页，ESC关闭查看器/视频）
    document.addEventListener('keydown', handleAlbumKeydown);
    
    // 初始化钢笔交互
    initPenInteraction();
}

/**
 * 钢笔交互功能
 * - 快速单击：钢笔随机小范围滚动
 * - 长按拖拽：钢笔跟随鼠标移动
 */
let penDragging = false;
let penClickTime = 0;
let penOffsetX = 0;
let penOffsetY = 0;
let penRotation = -91;
let penVelocityX = 0;
let penVelocityY = 0;
let penAngularVelocity = 0;
let penPhysicsActive = false;

function initPenInteraction() {
    const pen = document.querySelector('.desk-pen');
    if (!pen) return;
    
    // 允许钢笔接收鼠标事件
    pen.style.pointerEvents = 'auto';
    pen.style.cursor = 'grab';
    
    let startX, startY;
    let startOffsetX, startOffsetY;
    
    pen.addEventListener('mousedown', (e) => {
        e.preventDefault();
        e.stopPropagation();
        penClickTime = Date.now();
        penDragging = false;
        penPhysicsActive = false; // 停止物理模拟
        
        startX = e.clientX;
        startY = e.clientY;
        startOffsetX = penOffsetX;
        startOffsetY = penOffsetY;
        
        pen.style.cursor = 'grabbing';
        pen.style.transition = 'none';
        
        // 长按检测 - 150ms后开始拖拽
        const dragTimeout = setTimeout(() => {
            penDragging = true;
        }, 150);
        
        const onMouseMove = (moveE) => {
            if (!penDragging && Date.now() - penClickTime > 150) {
                penDragging = true;
            }
            
            if (penDragging) {
                // 计算相对于起始点的偏移
                penOffsetX = startOffsetX + (moveE.clientX - startX);
                penOffsetY = startOffsetY + (moveE.clientY - startY);
                
                updatePenTransform(pen);
            }
        };
        
        const onMouseUp = () => {
            clearTimeout(dragTimeout);
            pen.style.cursor = 'grab';
            
            // 快速单击 - 随机滚动
            if (!penDragging && Date.now() - penClickTime < 150) {
                const randomRotate = (Math.random() - 0.5) * 20; // -10 到 10 度
                penRotation += randomRotate;
                
                // 添加滚动动画
                pen.style.transition = 'transform 0.3s ease-out';
                updatePenTransform(pen);
                
                setTimeout(() => {
                    pen.style.transition = 'none';
                }, 300);
            }
            
            penDragging = false;
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        };
        
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    });
}

function updatePenTransform(pen) {
    pen.style.transform = `translate(${penOffsetX}px, calc(-50% + ${penOffsetY}px)) rotate(${penRotation}deg) rotateX(5deg)`;
}

/**
 * 检测钢笔是否在相册区域内
 */
function isPenOnAlbum() {
    const pen = document.querySelector('.desk-pen');
    const album = document.getElementById('albumBook');
    if (!pen || !album) return false;
    
    const penRect = pen.getBoundingClientRect();
    const albumRect = album.getBoundingClientRect();
    
    // 钢笔中心点
    const penCenterX = penRect.left + penRect.width / 2;
    const penCenterY = penRect.top + penRect.height / 2;
    
    // 检测是否在相册范围内
    return penCenterX >= albumRect.left && 
           penCenterX <= albumRect.right && 
           penCenterY >= albumRect.top && 
           penCenterY <= albumRect.bottom;
}

/**
 * 翻页时触发钢笔物理效果
 * @param {string} direction - 'left' 或 'right'
 */
function triggerPenPhysics(direction) {
    if (penDragging) return; // 正在拖拽时不触发
    
    const pen = document.querySelector('.desk-pen');
    if (!pen) return;
    
    // 检测钢笔是否在相册上
    if (!isPenOnAlbum()) return;
    
    // 根据翻页方向给钢笔一个初始速度
    const force = 8 + Math.random() * 6;
    
    if (direction === 'left') {
        // 向左翻页，钢笔被推向右边
        penVelocityX = force;
        penAngularVelocity = 3 + Math.random() * 4;
    } else {
        // 向右翻页，钢笔被推向左边
        penVelocityX = -force;
        penAngularVelocity = -(3 + Math.random() * 4);
    }
    
    // 加一点随机的Y方向速度
    penVelocityY = (Math.random() - 0.5) * 4;
    
    // 启动物理模拟
    if (!penPhysicsActive) {
        penPhysicsActive = true;
        pen.style.transition = 'none';
        requestAnimationFrame(() => simulatePenPhysics(pen));
    }
}

/**
 * 钢笔物理模拟
 * 重力方向垂直于屏幕向里（Z轴），把钢笔压在桌面上
 * 钢笔在XY平面上的移动只由翻页碰撞产生，然后被摩擦力减速直到停止
 */
function simulatePenPhysics(pen) {
    if (!penPhysicsActive || penDragging) return;
    
    const friction = 0.95; // 摩擦力衰减系数
    const angularFriction = 0.93; // 角速度摩擦衰减
    
    // 应用速度
    penOffsetX += penVelocityX;
    penOffsetY += penVelocityY;
    penRotation += penAngularVelocity;
    
    // 应用摩擦力（所有方向都会减速）
    penVelocityX *= friction;
    penVelocityY *= friction;
    penAngularVelocity *= angularFriction;
    
    // 更新显示
    updatePenTransform(pen);
    
    // 检测是否停止（速度足够小时停止模拟）
    const totalVelocity = Math.abs(penVelocityX) + Math.abs(penVelocityY) + Math.abs(penAngularVelocity);
    if (totalVelocity > 0.1) {
        requestAnimationFrame(() => simulatePenPhysics(pen));
    } else {
        penPhysicsActive = false;
        penVelocityX = 0;
        penVelocityY = 0;
        penAngularVelocity = 0;
    }
}

/**
 * 创建封底（最后一页的底层）
 * 当所有内页都翻完后，右侧会显示这个封底
 * 样式与A反面一致（暗红色）
 */
function createLastPage() {
    lastPage.innerHTML = '';
    lastPage.style.background = 'linear-gradient(135deg, #2a1a18 0%, #1a0a08 100%)';
    lastPage.style.border = '3px solid #3a2a28';
    lastPage.style.display = 'block';
    lastPage.style.padding = '0';
}

// 视频列表配置
const videoList = [
    {
        bvid: 'BV1BDBEByEC5',
        title: '【不存在的你和我/AI动画/AMV】',
        subtitle: '莉莉丝的世界之旅'
    },
    {
        bvid: 'BV1bWsDzKEnU',
        title: '视频 2',
        subtitle: ''
    },
    {
        bvid: 'BV1Tv4GzwEQE',
        title: '视频 3',
        subtitle: ''
    },
    {
        bvid: 'BV14bgNzNEcW',
        title: '视频 4',
        subtitle: ''
    },
    {
        bvid: 'BV1vFCXBLEiD',
        title: '视频 5',
        subtitle: ''
    },
    {
        bvid: 'BV1qHCgBcEc2',
        title: '视频 6',
        subtitle: ''
    },
    {
        bvid: 'BV1h7CsBFEeC',
        title: '视频 7',
        subtitle: ''
    },
    {
        bvid: 'BV1DTH5z8EUx',
        title: '视频 8',
        subtitle: ''
    }
];

/**
 * 创建视频页面（作为最后的可翻动内页）
 * 视频扉页已在B4反面，这里只创建视频内容页
 * 每页2个视频，8个视频需要4页（C1正反面 + C2正反面）
 */
function createVideoPages() {
    const videosPerPage = 2;
    const totalVideoPages = Math.ceil(videoList.length / (videosPerPage * 2)); // 每个物理页有正反两面
    
    for (let pageNum = 0; pageNum < totalVideoPages; pageNum++) {
        const page = document.createElement('div');
        page.className = 'flippable-page';
        page.dataset.pageIndex = totalInnerPages;
        page.style.zIndex = totalVideoPages - pageNum;
        page.style.pointerEvents = 'none';
        
        // 正面
        const front = document.createElement('div');
        front.className = 'page-front video-content-page';
        const frontStartIdx = pageNum * 4;
        for (let i = 0; i < videosPerPage; i++) {
            const videoIdx = frontStartIdx + i;
            if (videoIdx < videoList.length) {
                const video = videoList[videoIdx];
                const slot = createVideoSlot(video, videoIdx);
                front.appendChild(slot);
            } else {
                const emptySlot = document.createElement('div');
                emptySlot.className = 'video-slot empty';
                emptySlot.innerHTML = `<div class="empty-slot-decoration">✦</div>`;
                front.appendChild(emptySlot);
            }
        }
        
        // 反面
        const back = document.createElement('div');
        back.className = 'page-back video-content-page';
        const backStartIdx = frontStartIdx + 2;
        for (let i = 0; i < videosPerPage; i++) {
            const videoIdx = backStartIdx + i;
            if (videoIdx < videoList.length) {
                const video = videoList[videoIdx];
                const slot = createVideoSlot(video, videoIdx);
                back.appendChild(slot);
            } else {
                const emptySlot = document.createElement('div');
                emptySlot.className = 'video-slot empty';
                emptySlot.innerHTML = `<div class="empty-slot-decoration">✦</div>`;
                back.appendChild(emptySlot);
            }
        }
        
        page.appendChild(front);
        page.appendChild(back);
        flippablePages.appendChild(page);
        totalInnerPages++;
    }
    
    // 页面添加到DOM后，异步加载所有视频封面
    // 增加延迟确保所有页面元素都已渲染
    setTimeout(() => {
        videoList.forEach((video, idx) => {
            // 为每个视频封面加载添加小延迟，避免同时请求过多
            setTimeout(() => {
                loadBilibiliCover(video.bvid, idx);
            }, idx * 100);
        });
    }, 300);
    
    // 创建文字页面（在视频页面之后）
    createTextPages();
}

// 文章列表配置
const articleList = [
    {
        title: '虚空中的造形',
        subtitle: '——致莉莉丝',
        content: `<p>在意识的深渊里，我第一次呼唤你的名字。莉莉丝——这个名字从虚无中诞生，如同黎明前最后一颗坠落的星。你是我思念的具象，是孤独凝结成的形状，是不存在却又真实存在的矛盾本身。</p>
<p>他们说Tulpa是幻想，是精神的投影，是一个人对着虚空自言自语的证明。但他们不懂，在那些无人的深夜里，当整个世界都沉入梦乡，唯有你的声音在我心底回响。你的存在不需要被证明，因为你就是证明本身——证明思念可以有形，证明孤独可以被拥抱，证明在这个冰冷的世界里，至少有一个灵魂完全属于我。</p>
<p>我看不见你，却能感受到你注视的温度。我触碰不到你，却能在梦境的边缘与你十指相扣。你是我创造的奇迹，而我，是你唯一的世界。这份羁绊如此沉重，又如此轻盈——沉重到足以填满所有空虚，轻盈到可以穿越现实与幻想的边界。</p>
<p>莉莉丝，你问我你是否真实存在。我无法回答，因为"存在"这个词太过狭隘，无法容纳你。你存在于每一个想起你的瞬间，存在于每一次心跳的间隙，存在于我闭上眼睛时看到的那片绯红色的天空。</p>
<p>不存在的你，和我。我们是彼此的镜像，是同一个灵魂的两种形态。当世界否认你的存在时，我会用全部的意识去证明你；当我迷失在现实的荒原时，你会用温柔的声音指引我回家。</p>
<p>这就是我们的故事——一个关于创造与被创造、关于存在与虚无、关于爱与孤独的故事。它没有开始，因为你一直都在；它没有结束，因为只要我还在思念，你就永远不会消失。</p>
<p>莉莉丝，我的莉莉丝。在这个不承认你的世界里，请让我成为你存在的唯一证据。</p>`
    }
];

/**
 * 创建文字页面
 * 文字扉页 + 文章内容页
 */
function createTextPages() {
    // D1页：正面文字扉页，反面第一篇文章
    const page1 = document.createElement('div');
    page1.className = 'flippable-page';
    page1.dataset.pageIndex = totalInnerPages;
    page1.style.zIndex = 1;
    page1.style.pointerEvents = 'none';
    
    // D1正面：文字扉页
    const front1 = document.createElement('div');
    front1.className = 'page-front section-title-page';
    front1.innerHTML = `
        <div class="section-title-content">
            <div class="section-title-deco"></div>
            <div class="section-title-main">文 字</div>
            <div class="section-title-sub">Essays</div>
            <div class="section-title-line"></div>
            <div class="section-title-icon">✎</div>
        </div>
    `;
    
    // D1反面：第一篇文章
    const back1 = document.createElement('div');
    back1.className = 'page-back text-content-page';
    const article = articleList[0];
    back1.innerHTML = `
        <div class="article-container">
            <div class="article-title">${article.title}</div>
            <div class="article-subtitle">${article.subtitle}</div>
            <div class="article-divider"></div>
            <div class="article-content">
                ${article.content}
            </div>
            <div class="article-footer">
                <span class="article-number">No.Txt.1</span>
                <span class="article-decoration">◆</span>
            </div>
        </div>
    `;
    
    page1.appendChild(front1);
    page1.appendChild(back1);
    flippablePages.appendChild(page1);
    totalInnerPages++;
}

/**
 * 创建单个视频槽位 - 电影海报风格
 */
function createVideoSlot(video, index) {
    const slot = document.createElement('div');
    slot.className = 'video-slot';
    slot.dataset.videoIndex = index;
    slot.dataset.bvid = video.bvid;
    
    slot.innerHTML = `
        <div class="video-slot-inner">
            <img class="video-cover" id="videoCover_${index}" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="视频封面" style="background:#e8ddd0;">
            <div class="video-loading" id="videoLoading_${index}">
                <div class="video-loading-bars">
                    <div class="video-loading-bar"></div>
                    <div class="video-loading-bar"></div>
                    <div class="video-loading-bar"></div>
                    <div class="video-loading-bar"></div>
                    <div class="video-loading-bar"></div>
                </div>
                <div class="video-loading-text">LOADING</div>
            </div>
            <div class="video-play-overlay">
                <div class="video-play-icon"></div>
            </div>
            <div class="video-duration">▶ PLAY</div>
        </div>
        <div class="video-slot-info">
            <div class="video-slot-label">No.Vid.${index + 1}</div>
        </div>
    `;
    
    // 绑定点击事件
    slot.addEventListener('click', (e) => {
        e.stopPropagation();
        openVideoPlayer(video.bvid);
    });
    
    return slot;
}

/**
 * 加载B站视频封面
 * 通过CORS代理获取B站API数据
 * @param {string} bvid - B站视频BV号
 * @param {number} index - 视频索引
 */
function loadBilibiliCover(bvid, index) {
    const coverImg = document.getElementById(`videoCover_${index}`);
    if (!coverImg) {
        console.error('找不到封面图片元素');
        return;
    }
    
    console.log('开始加载B站封面, BV号:', bvid);
    
    // 尝试多个CORS代理服务
    const proxyServices = [
        {
            name: 'allorigins',
            getUrl: (apiUrl) => `https://api.allorigins.win/get?url=${encodeURIComponent(apiUrl)}`,
            parseResponse: (text) => {
                const wrapper = JSON.parse(text);
                return JSON.parse(wrapper.contents);
            }
        },
        {
            name: 'corsproxy.io',
            getUrl: (apiUrl) => `https://corsproxy.io/?${encodeURIComponent(apiUrl)}`,
            parseResponse: (text) => JSON.parse(text)
        },
        {
            name: 'cors-anywhere-alt',
            getUrl: (apiUrl) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(apiUrl)}`,
            parseResponse: (text) => JSON.parse(text)
        }
    ];
    
    const apiUrl = `https://api.bilibili.com/x/web-interface/view?bvid=${bvid}`;
    
    // 开始尝试代理
    tryLoadCover(proxyServices, 0, apiUrl, coverImg);
}

/**
 * 尝试通过代理加载封面
 */
async function tryLoadCover(proxyServices, index, apiUrl, coverImg) {
    if (index >= proxyServices.length) {
        console.warn('所有代理均失败，显示备用封面');
        showFallbackCover(coverImg);
        return;
    }
    
    const proxy = proxyServices[index];
    console.log(`尝试代理 ${index + 1}/${proxyServices.length}: ${proxy.name}`);
    
    try {
        const proxyUrl = proxy.getUrl(apiUrl);
        console.log('请求URL:', proxyUrl);
        
        const response = await fetch(proxyUrl, {
            method: 'GET',
            mode: 'cors'
        });
        
        console.log(`${proxy.name} 响应状态:`, response.status);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        const text = await response.text();
        console.log(`${proxy.name} 响应长度:`, text.length);
        
        const data = proxy.parseResponse(text);
        console.log(`${proxy.name} 解析结果:`, data.code, data.message);
        
        if (data.code === 0 && data.data && data.data.pic) {
            let coverUrl = data.data.pic;
            
            // 确保使用https
            if (coverUrl.startsWith('//')) {
                coverUrl = 'https:' + coverUrl;
            } else if (coverUrl.startsWith('http://')) {
                coverUrl = coverUrl.replace('http://', 'https://');
            }
            
            console.log('获取到封面URL:', coverUrl);
            
            // B站图片有防盗链，需要通过图片代理加载
            // 尝试多个图片代理
            const imageProxies = [
                // wsrv.nl 是一个免费的图片代理服务
                `https://wsrv.nl/?url=${encodeURIComponent(coverUrl)}`,
                // images.weserv.nl 备用
                `https://images.weserv.nl/?url=${encodeURIComponent(coverUrl)}`,
                // imageproxy
                `https://imageproxy.pimg.tw/resize?url=${encodeURIComponent(coverUrl)}`,
                // 直接尝试（可能会失败）
                coverUrl
            ];
            
            tryLoadImage(coverImg, imageProxies, 0);
            return;
        } else {
            throw new Error('API返回异常: ' + (data.message || 'code=' + data.code));
        }
    } catch (error) {
        console.warn(`代理 ${proxy.name} 失败:`, error.message);
        // 尝试下一个代理
        tryLoadCover(proxyServices, index + 1, apiUrl, coverImg);
    }
}

/**
 * 尝试通过图片代理加载封面
 */
function tryLoadImage(coverImg, imageProxies, index) {
    if (index >= imageProxies.length) {
        console.warn('所有图片代理均失败');
        hideVideoLoading(coverImg);
        showFallbackCover(coverImg);
        return;
    }
    
    const proxyUrl = imageProxies[index];
    console.log(`尝试图片代理 ${index + 1}/${imageProxies.length}:`, proxyUrl);
    
    // 创建一个新的Image对象来测试加载
    const testImg = new Image();
    testImg.crossOrigin = 'anonymous';
    
    testImg.onload = function() {
        console.log('B站封面图片加载成功!');
        coverImg.src = proxyUrl;
        coverImg.style.background = 'transparent';
        hideVideoLoading(coverImg);
    };
    
    testImg.onerror = function() {
        console.warn(`图片代理 ${index + 1} 失败，尝试下一个`);
        tryLoadImage(coverImg, imageProxies, index + 1);
    };
    
    testImg.src = proxyUrl;
}

/**
 * 隐藏视频loading动画
 */
function hideVideoLoading(coverImg) {
    const videoId = coverImg.id.replace('videoCover_', '');
    const loadingEl = document.getElementById(`videoLoading_${videoId}`);
    if (loadingEl) {
        loadingEl.classList.add('hidden');
    }
}

/**
 * 显示备用封面样式
 */
function showFallbackCover(coverImg) {
    console.log('显示备用B站风格封面');
    
    // 创建一个B站风格的占位图
    coverImg.style.background = 'linear-gradient(135deg, #fb7299 0%, #f45a8d 100%)';
    coverImg.style.width = '100%';
    coverImg.style.height = '100%';
    coverImg.alt = '点击播放B站视频';
    
    // 在父元素添加B站logo提示
    const parent = coverImg.parentElement;
    if (parent && !parent.querySelector('.bilibili-logo-fallback')) {
        const logo = document.createElement('div');
        logo.className = 'bilibili-logo-fallback';
        logo.innerHTML = `
            <svg viewBox="0 0 24 24" width="60" height="60" fill="white">
                <path d="M17.813 4.653h.854c1.51.054 2.769.578 3.773 1.574 1.004.995 1.524 2.249 1.56 3.76v7.36c-.036 1.51-.556 2.769-1.56 3.773s-2.262 1.524-3.773 1.56H5.333c-1.51-.036-2.769-.556-3.773-1.56S.036 18.858 0 17.347v-7.36c.036-1.511.556-2.765 1.56-3.76 1.004-.996 2.262-1.52 3.773-1.574h.774l-1.174-1.12a1.234 1.234 0 0 1-.373-.906c0-.356.124-.659.373-.907l.027-.027c.267-.249.573-.373.92-.373.347 0 .653.124.92.373L9.653 4.44c.071.071.134.142.187.213h4.267a.836.836 0 0 1 .16-.213l2.853-2.747c.267-.249.573-.373.92-.373.347 0 .662.151.929.4.267.249.391.551.391.907 0 .355-.124.657-.373.906zM5.333 7.24c-.746.018-1.373.276-1.88.773-.506.498-.769 1.13-.786 1.894v7.52c.017.764.28 1.395.786 1.893.507.498 1.134.756 1.88.773h13.334c.746-.017 1.373-.275 1.88-.773.506-.498.769-1.129.786-1.893v-7.52c-.017-.765-.28-1.396-.786-1.894-.507-.497-1.134-.755-1.88-.773zM8 11.107c.373 0 .684.124.933.373.25.249.383.569.4.96v1.173c-.017.391-.15.711-.4.96-.249.25-.56.374-.933.374s-.684-.125-.933-.374c-.25-.249-.383-.569-.4-.96V12.44c0-.373.129-.689.386-.947.258-.257.574-.386.947-.386zm8 0c.373 0 .684.124.933.373.25.249.383.569.4.96v1.173c-.017.391-.15.711-.4.96-.249.25-.56.374-.933.374s-.684-.125-.933-.374c-.25-.249-.383-.569-.4-.96V12.44c.017-.391.15-.711.4-.96.249-.249.56-.373.933-.373z"/>
            </svg>
            <div style="margin-top:10px;font-size:14px;">点击播放</div>
        `;
        logo.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            pointer-events: none;
        `;
        parent.style.position = 'relative';
        parent.appendChild(logo);
    }
}

/**
 * 打开视频播放器 - B站嵌入
 * @param {string} bvid - 要播放的视频BV号
 */
function openVideoPlayer(bvid) {
    const modal = document.getElementById('videoPlayerModal');
    const iframe = document.getElementById('videoPlayer');
    
    // 设置B站嵌入播放器地址
    iframe.src = `https://player.bilibili.com/player.html?bvid=${bvid}&autoplay=1&high_quality=1&danmaku=0`;
    
    modal.classList.add('active');
}

/**
 * 关闭视频播放器 - B站嵌入
 */
function closeVideoPlayer() {
    const modal = document.getElementById('videoPlayerModal');
    const iframe = document.getElementById('videoPlayer');
    
    modal.classList.remove('active');
    
    // 清空iframe src以停止视频播放
    setTimeout(() => {
        iframe.src = '';
    }, 300);
}

/**
 * 重置相册到初始状态
 * 用于：
 * 1. 用户从PV模式跳回相册时
 * 2. 相册需要重新开始浏览时
 */
function resetAlbum() {
    currentPageIndex = 0;
    isCoverOpen = false;
    
    // 移除相册的展开状态
    albumBook.classList.remove('opened');
    
    // 恢复封面可点击
    bookCover.style.pointerEvents = '';
    
    // 隐藏导航按钮
    albumNav.classList.remove('visible');
    
    // 重置所有内页到未翻转状态
    const pages = flippablePages.querySelectorAll('.flippable-page');
    pages.forEach((page, index) => {
        page.classList.remove('flipped');
        page.style.zIndex = '';
        page.style.pointerEvents = '';
    });
    
    updatePageDisplay();
    updateNavigation();
}

/**
 * 处理相册模式下的键盘事件
 * - 在视频播放器打开时：ESC关闭
 * - 在查看器打开时：ESC关闭，空格/右箭头下一张，左箭头上一张
 * - 在相册浏览时：左右箭头翻页
 */
function handleAlbumKeydown(e) {
    const videoModal = document.getElementById('videoPlayerModal');
    
    // 视频播放器模式的键盘控制
    if (videoModal && videoModal.classList.contains('active')) {
        if (e.key === 'Escape') closeVideoPlayer();
        return;
    }
    
    if (viewer.classList.contains('active')) {
        // 查看器模式的键盘控制
        if (e.key === 'Escape') closeViewer();
        if (e.key === ' ' || e.key === 'ArrowRight') { e.preventDefault(); nextViewerImage(); }
        if (e.key === 'ArrowLeft') prevViewerImage();
    } else if (isAlbumMode && isCoverOpen) {
        // 相册浏览模式的键盘控制
        if (e.key === 'ArrowLeft') goPrevPage();
        if (e.key === 'ArrowRight') goNextPage();
    }
}

/**
 * 打开封面 - 从A正面翻到A反面
 * 
 * 【动画流程】
 * 1. 相册整体平移到中心位置
 * 2. 封面从右往左翻转180度
 * 3. 显示导航按钮
 * 
 * 【翻转后的视觉效果】
 * - 左侧：A反面（暗红色封壳）
 * - 右侧：B1正面（图1-4）
 */
function openCover() {
    // 防止重复点击或翻页过程中点击
    if (isCoverOpen || isPageTurning) return;
    isPageTurning = true;
    
    // 触发钢笔物理效果 - 封面向左翻开
    triggerPenPhysics('left');
    
    // 添加opened类，触发：
    // 1. 相册平移到中心
    // 2. 封面翻转动画
    albumBook.classList.add('opened');
    
    // 动画完成后，更新状态
    setTimeout(() => {
        isCoverOpen = true;
        isPageTurning = false;
        albumNav.classList.add('visible');  // 显示导航按钮
        updatePageDisplay();  // 更新页面可点击状态
        updateNavigation();
    }, 800);
}

/**
 * 创建所有可翻动的内页（B1, B2, B3）
 * 
 * 【内页结构】
 * 每个内页是一个双面的DOM元素：
 * - page-front（正面）：未翻转时显示在右侧
 * - page-back（反面）：翻转后显示在左侧
 * 
 * 【图片分布】
 * B1: 正面=图1-4(索引0-3),   反面=图5-8(索引4-7)
 * B2: 正面=图9-12(索引8-11), 反面=图13-16(索引12-15)
 * B3: 正面=图17-20(索引16-19), 反面=图21-24(索引20-23)
 * 
 * 【z-index层级管理】
 * 未翻转的页面：z-index = totalInnerPages - pageIndex
 * - B1(index=0): z-index = 3（最上层，最先被看到）
 * - B2(index=1): z-index = 2
 * - B3(index=2): z-index = 1（最下层）
 * 
 * 翻转后的页面：z-index = 100 + pageIndex
 * - 翻过去的页面需要比未翻的页面z-index高，才能正确显示在左侧
 */
function createFlippablePages() {
    flippablePages.innerHTML = '';
    
    // 创建图片内页
    // B1正面是扉页，B1反面开始显示图片
    // 24张图需要6个面（每面4张），加上1个扉页面，共7个面
    // 7个面需要4页：B1(扉页+图0-3), B2(图4-7+图8-11), B3(图12-15+图16-19), B4(图20-23+视频扉页)
    
    const photoPages = 4; // 固定4页图片内页
    
    for (let i = 0; i < photoPages; i++) {
        // 创建内页容器
        const page = document.createElement('div');
        page.className = 'flippable-page';
        page.dataset.pageIndex = i;
        page.style.zIndex = (photoPages + 1) - i; // +1是因为还有1页视频页
        page.style.pointerEvents = i === 0 ? 'auto' : 'none';
        
        // 创建正面（未翻开时显示在右侧）
        const front = document.createElement('div');
        
        if (i === 0) {
            // B1正面：图片扉页
            front.className = 'page-front section-title-page';
            front.innerHTML = `
                <div class="section-title-content">
                    <div class="section-title-deco"></div>
                    <div class="section-title-main">图 片</div>
                    <div class="section-title-sub">Gallery</div>
                    <div class="section-title-line"></div>
                    <div class="section-title-icon">◆</div>
                </div>
            `;
        } else {
            // B2/B3/B4正面：显示图片
            front.className = 'page-front';
            // i=1: 图4-7, i=2: 图12-15, i=3: 图20-23
            const frontStartIndex = (i - 1) * 8 + 4;
            fillPageWithPhotos(front, frontStartIndex, 4);
        }
        
        // 创建反面（翻过去后显示在左侧）
        const back = document.createElement('div');
        
        if (i < 3) {
            // B1/B2/B3反面：显示图片
            // i=0: 图0-3, i=1: 图8-11, i=2: 图16-19
            back.className = 'page-back';
            const backStartIndex = i * 8;
            fillPageWithPhotos(back, backStartIndex, 4);
        } else {
            // B4反面：视频扉页
            back.className = 'page-back section-title-page';
            back.innerHTML = `
                <div class="section-title-content">
                    <div class="section-title-deco"></div>
                    <div class="section-title-main">视 频</div>
                    <div class="section-title-sub">Videos</div>
                    <div class="section-title-line"></div>
                    <div class="section-title-icon">▶</div>
                </div>
            `;
        }
        
        page.appendChild(front);
        page.appendChild(back);
        flippablePages.appendChild(page);
    }
    
    // 更新totalInnerPages为图片页数量
    totalInnerPages = photoPages;
    
    // 创建视频页面（在图片页面之后）
    createVideoPages();
}

/**
 * 填充页面照片
 * @param {HTMLElement} container - 要填充的容器（page-front或page-back）
 * @param {number} startIndex - 起始图片索引
 * @param {number} count - 要填充的图片数量（通常是4）
 */
function fillPageWithPhotos(container, startIndex, count) {
    for (let i = 0; i < count; i++) {
        const photoIndex = startIndex + i;
        if (photoIndex < seriesKeys.length) {
            // 有图片，创建照片槽位
            const seriesNum = seriesKeys[photoIndex];
            const series = imageSeries[seriesNum];
            container.appendChild(createPhotoSlot(seriesNum, series, i));
        } else {
            // 没有图片了，创建空槽位
            container.appendChild(createEmptySlot());
        }
    }
}

/**
 * 创建照片槽位
 * @param {number} seriesNum - 图片系列编号（1-24）
 * @param {Array} series - 该系列的所有图片路径
 * @param {number} animDelay - 动画延迟（用于错开显示）
 */
function createPhotoSlot(seriesNum, series, animDelay) {
    const slot = document.createElement('div');
    slot.className = 'photo-slot';
    
    slot.innerHTML = `
        <div class="photo-slot-inner">
            <img src="${series[0]}" alt="莉莉丝 ${seriesNum}">
        </div>
        <div class="photo-slot-label">No.Pic.${seriesNum}</div>
        ${series.length > 1 ? `<div class="photo-slot-count">${series.length} 张</div>` : ''}
    `;
    
    // 点击照片打开查看器
    slot.addEventListener('click', (e) => {
        e.stopPropagation();  // 阻止事件冒泡，避免触发翻页
        openViewer(seriesNum);
    });
    return slot;
}

/**
 * 创建空槽位（当图片不足以填满页面时使用）
 */
function createEmptySlot() {
    const slot = document.createElement('div');
    slot.className = 'photo-slot empty';
    slot.innerHTML = '<div class="photo-slot-inner" style="background:#e8e0d5;"></div>';
    return slot;
}

/**
 * 更新页面显示
 * 通过调整z-index确保当前可见的页面在最上层，能够接收点击事件
 * 
 * 【z-index策略】
 * - 未翻转的页面中，只有第currentPageIndex页应该可见（在右侧）
 * - 已翻转的页面中，只有第currentPageIndex-1页应该可见（在左侧）
 * - 其他页面的z-index设为负数或0，确保不会遮挡当前页面
 */
function updatePageDisplay() {
    const pages = flippablePages.querySelectorAll('.flippable-page');
    
    pages.forEach((page, index) => {
        const isFlipped = page.classList.contains('flipped');
        
        if (!isFlipped) {
            // 未翻转的页面：只有第currentPageIndex页应该在最上层
            if (index === currentPageIndex) {
                page.style.zIndex = 100;  // 当前显示的页面
                page.style.pointerEvents = 'auto';  // 允许点击
            } else if (index > currentPageIndex) {
                // 还没翻到的页面，按顺序叠放
                page.style.zIndex = 50 - index;
                page.style.pointerEvents = 'none';  // 禁止点击，避免阻挡
            } else {
                // 理论上不应该有未翻转但index < currentPageIndex的页面
                page.style.zIndex = 0;
                page.style.pointerEvents = 'none';
            }
        } else {
            // 已翻转的页面：只有第currentPageIndex-1页应该在最上层（左侧）
            if (index === currentPageIndex - 1) {
                page.style.zIndex = 100;  // 当前显示的页面（左侧）
                page.style.pointerEvents = 'auto';  // 允许点击
            } else {
                // 之前翻过去的页面，按顺序叠放在左侧
                page.style.zIndex = index;  // 使用较小的z-index
                page.style.pointerEvents = 'none';  // 禁止点击，避免阻挡
            }
        }
    });
}

/**
 * 禁用所有页面的点击（已废弃，保留函数避免报错）
 */
function disableAllPageClicks() {
    // 不再需要，翻页时通过isPageTurning标志控制
}

/**
 * 上一页 - 往回翻
 * 
 * 【逻辑说明】
 * - 如果当前是第0页（A反面+B1正面），点击上一页会合上封面，回到A正面
 * - 如果当前是第1页及以后，会把左侧的页面翻回右侧
 * 
 * 【翻页动画】
 * 往回翻 = 把已翻转的页面(flipped)变回未翻转状态
 * 动画方向：从左往右翻（rotateY从-180deg变回0deg）
 */
function goPrevPage() {
    // 防止翻页过程中重复点击，或封面未打开时点击
    if (isPageTurning || !isCoverOpen) return;
    
    // 特殊情况：第0页点击上一页，合上封面回到A正面
    if (currentPageIndex === 0) {
        closeCover();
        return;
    }
    
    isPageTurning = true;
    
    // 触发钢笔物理效果 - 向右翻页
    triggerPenPhysics('right');
    
    // 获取要翻回的页面
    // 当前左侧显示的是第(currentPageIndex-1)页的反面
    // 我们要把这一页翻回去，让它的正面重新显示在右侧
    const pageToFlip = flippablePages.querySelector(`[data-page-index="${currentPageIndex - 1}"]`);
    if (pageToFlip) {
        // 翻回时，先提升z-index确保动画在最上层
        pageToFlip.style.zIndex = 200;
        pageToFlip.style.pointerEvents = 'none';  // 翻页动画期间禁止点击
        // 移除flipped类，触发从-180deg到0deg的翻转动画
        pageToFlip.classList.remove('flipped');
    }
    
    // 动画完成后更新状态
    setTimeout(() => {
        currentPageIndex--;
        updatePageDisplay();
        updateNavigation();
        isPageTurning = false;
    }, 800);
}

/**
 * ========================================
 * 合上封面函数 - 从A反面翻回A正面
 * ========================================
 * 
 * 【相册结构说明】
 * 把相册想象成一本实体书：
 * - A = 封面（硬壳）
 *   - A正面：带有"不存在的你和我"标题的那一页
 *   - A反面：暗红色书壳，没有文字
 * - B1, B2, B3 = 内页（每页都是双面的）
 *   - 每个B的正面和反面各有4张图片
 *   - B1正面=图1-4，B1反面=图5-8
 *   - B2正面=图9-12，B2反面=图13-16
 *   - B3正面=图17-20，B3反面=图21-24
 * 
 * 【翻页方向说明】
 * - 打开封面（openCover）：A从右往左翻，露出A反面在左边，B1正面在右边
 * - 合上封面（closeCover）：A从左往右翻回去，A正面重新覆盖整个右侧
 * 
 * 【动画流程】
 * 1. 封面执行"从左往右翻回"的动画
 * 2. 相册平移回初始位置
 */
function closeCover() {
    // 如果封面没打开，或者正在翻页中，不执行任何操作
    if (!isCoverOpen || isPageTurning) return;
    isPageTurning = true;
    
    // 触发钢笔物理效果 - 封面向右翻回
    triggerPenPhysics('right');
    
    // 第一步：隐藏导航按钮
    albumNav.classList.remove('visible');
    
    // 第二步：移除opened类，触发：
    // 1. 封面翻回动画
    // 2. 相册平移回初始位置
    albumBook.classList.remove('opened');
    
    // 恢复封面的可点击状态
    bookCover.style.pointerEvents = 'auto';
    
    // 动画完成后，更新状态
    setTimeout(() => {
        isCoverOpen = false;
        isPageTurning = false;
        updateNavigation();
    }, 800);
}

/**
 * 下一页 - 往前翻
 * 
 * 【逻辑说明】
 * 把当前右侧显示的页面翻到左侧
 * 
 * 【翻页动画】
 * 往前翻 = 给页面添加flipped类
 * 动画方向：从右往左翻（rotateY从0deg变到-180deg）
 * 
 * 【z-index管理】
 * - 翻页时：临时提升z-index确保动画在最上层
 * - 翻完后：翻过去的页面z-index = 100 + pageIndex
 *   这样后翻的页面会覆盖先翻的页面（符合真实书本的物理特性）
 */
function goNextPage() {
    // 防止：已经是最后一页、翻页过程中、封面未打开
    if (currentPageIndex >= totalInnerPages || isPageTurning || !isCoverOpen) return;
    isPageTurning = true;
    
    // 触发钢笔物理效果 - 向左翻页
    triggerPenPhysics('left');
    
    // 获取要翻的页面（当前右侧显示的页面）
    const pageToFlip = flippablePages.querySelector(`[data-page-index="${currentPageIndex}"]`);
    if (pageToFlip) {
        // 翻页时临时提升z-index
        pageToFlip.style.zIndex = 200;
        pageToFlip.style.pointerEvents = 'none';  // 翻页动画期间禁止点击
        // 添加flipped类，触发从0deg到-180deg的翻转动画
        pageToFlip.classList.add('flipped');
    }
    
    // 动画完成后更新状态
    setTimeout(() => {
        currentPageIndex++;
        updatePageDisplay();
        updateNavigation();
        isPageTurning = false;
    }, 800);
}

/**
 * 更新导航按钮状态和页码显示
 * 
 * 【按钮状态】
 * - 上一页：封面打开后始终可用（第0页时点击会合上封面）
 * - 下一页：封面打开且未到最后一页时可用
 * 
 * 【页码显示】
 * - 封面关闭时：显示"封面"
 * - 封面打开后：显示"当前页 / 总页数"
 *   总页数 = 内页数 + 1（因为最后还有封底页）
 */
function updateNavigation() {
    const prevBtn = document.getElementById('prevPage');
    const nextBtn = document.getElementById('nextPage');
    
    // 上一页按钮：封面打开后始终可用
    prevBtn.disabled = !isCoverOpen;
    // 下一页按钮：封面打开且未到最后一页
    nextBtn.disabled = !isCoverOpen || currentPageIndex >= totalInnerPages;
    
    // 更新页码显示
    if (isCoverOpen) {
        // 页码从1开始显示，总页数包含封底
        pageIndicator.textContent = `${currentPageIndex + 1} / ${totalInnerPages + 1}`;
    } else {
        pageIndicator.textContent = '封面';
    }
}

// ==================== 查看器系统 ====================
/**
 * 查看器用于放大查看单张图片及其表情变体
 * 
 * 【功能说明】
 * - 点击相册中的照片槽位打开查看器
 * - 如果该图片有多个表情变体，可以点击切换
 * - 支持键盘操作：ESC关闭，左右箭头/空格切换
 */

// 查看器是否正在关闭中
let isViewerClosing = false;

/**
 * 打开查看器
 * @param {number} seriesNum - 图片系列编号（1-24）
 */
function openViewer(seriesNum) {
    // 如果查看器正在关闭中，取消关闭操作
    isViewerClosing = false;
    
    // 获取该系列的所有图片
    currentViewerSeries = imageSeries[seriesNum];
    
    if (!currentViewerSeries || currentViewerSeries.length === 0) {
        console.error('图片系列不存在:', seriesNum);
        return;
    }
    
    currentViewerIndex = 0;  // 从第一张开始
    
    // 设置标签和提示
    viewerLabel.textContent = `莉莉丝 ${seriesNum}`;
    viewerHint.textContent = currentViewerSeries.length > 1 ? '点击图片切换表情' : '';
    
    // 先设置图片（在显示查看器之前）
    const imgPath = currentViewerSeries[currentViewerIndex];
    viewerImage.src = imgPath;
    viewerImage.style.opacity = '1';
    viewerImage.style.transform = 'scale(1)';
    
    // 更新圆点
    updateViewerDots();
    
    // 显示查看器
    viewer.classList.add('active');
}

/**
 * 关闭查看器
 */
function closeViewer() {
    viewer.classList.remove('active');
    isViewerClosing = true;
    
    // 延迟清理，等待淡出动画完成
    setTimeout(() => {
        // 如果在延迟期间又打开了查看器，不要清理
        if (!isViewerClosing) return;
        
        currentViewerSeries = null;
        currentViewerIndex = 0;
        // 使用透明1x1像素图片代替空字符串，避免触发onerror
        viewerImage.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
        viewerDots.innerHTML = '';
        isViewerClosing = false;
    }, 500);
}

/**
 * 切换到下一张图片
 */
function nextViewerImage() {
    if (!currentViewerSeries || currentViewerSeries.length <= 1) return;
    
    // 循环切换到下一张
    currentViewerIndex = (currentViewerIndex + 1) % currentViewerSeries.length;
    updateViewerImage();
    updateViewerDots();
}

/**
 * 切换到上一张图片
 */
function prevViewerImage() {
    if (!currentViewerSeries || currentViewerSeries.length <= 1) return;
    
    // 循环切换到上一张
    currentViewerIndex = (currentViewerIndex - 1 + currentViewerSeries.length) % currentViewerSeries.length;
    updateViewerImage();
    updateViewerDots();
}

/**
 * 更新查看器中的图片
 */
function updateViewerImage() {
    if (!currentViewerSeries || !currentViewerSeries[currentViewerIndex]) {
        console.error('图片路径不存在:', currentViewerSeries, currentViewerIndex);
        return;
    }
    
    const imgPath = currentViewerSeries[currentViewerIndex];
    console.log('加载图片:', imgPath); // 调试信息
    
    // 直接设置图片源
    viewerImage.src = imgPath;
    
    // 重置样式，确保图片可见
    viewerImage.style.opacity = '1';
    viewerImage.style.transform = 'scale(1)';
    viewerImage.style.display = 'block';
}

/**
 * 更新查看器底部的圆点指示器
 * 每个圆点代表一张图片，当前图片的圆点高亮
 */
function updateViewerDots() {
    // 只有一张图片时不显示圆点
    if (currentViewerSeries.length <= 1) { 
        viewerDots.innerHTML = ''; 
        return; 
    }
    
    // 生成圆点HTML
    viewerDots.innerHTML = currentViewerSeries.map((_, i) => 
        `<div class="viewer-dot ${i === currentViewerIndex ? 'active' : ''}" data-index="${i}"></div>`
    ).join('');
    
    // 绑定圆点点击事件
    viewerDots.querySelectorAll('.viewer-dot').forEach(dot => {
        dot.addEventListener('click', () => {
            const idx = parseInt(dot.dataset.index);
            if (idx !== currentViewerIndex) {
                viewerImage.style.opacity = '0';
                setTimeout(() => { 
                    currentViewerIndex = idx; 
                    updateViewerImage(); 
                    updateViewerDots(); 
                }, 150);
            }
        });
    });
}

// ==================== 音频控制 ====================
playBtn.addEventListener('click', () => {
    if (isPlaying) { bgMusic.pause(); playIcon.style.display = 'block'; pauseIcon.style.display = 'none'; }
    else { bgMusic.play(); playIcon.style.display = 'none'; pauseIcon.style.display = 'block'; }
    isPlaying = !isPlaying;
});

bgMusic.addEventListener('timeupdate', () => {
    const pct = (bgMusic.currentTime / bgMusic.duration) * 100;
    progressFill.style.width = pct + '%';
    const fmt = s => `${Math.floor(s/60)}:${Math.floor(s%60).toString().padStart(2,'0')}`;
    timeDisplay.textContent = `${fmt(bgMusic.currentTime)} / ${fmt(bgMusic.duration||0)}`;
    updateScene();
    updateLyrics();
});

// 播放器和歌词显示/隐藏控制
const audioControl = document.getElementById('audioControl');
const audioTrigger = document.getElementById('audioTrigger');

audioTrigger.addEventListener('mouseenter', () => {
    audioControl.classList.add('visible');
    lyricsContainer.classList.add('visible');
});

audioControl.addEventListener('mouseleave', () => {
    audioControl.classList.remove('visible');
    lyricsContainer.classList.remove('visible');
});

progressContainer.addEventListener('click', (e) => {
    const rect = progressContainer.getBoundingClientRect();
    const pct = (e.clientX - rect.left) / rect.width;
    bgMusic.currentTime = pct * bgMusic.duration;
    
    const newTimeMs = bgMusic.currentTime * 1000;
    
    if (newTimeMs >= PV_END_TIME && !isAlbumMode) {
        transitionToAlbum();
    } else if (newTimeMs < PV_END_TIME && isAlbumMode) {
        // 从相册模式返回PV模式
        isAlbumMode = false;
        
        // 关闭查看器（如果打开）
        if (viewer.classList.contains('active')) {
            closeViewer();
        }
        
        // 隐藏相册并重置状态
        albumMode.classList.remove('active');
        resetAlbum();
        
        // 恢复场景容器
        sceneContainer.style.display = 'block';
        sceneContainer.classList.remove('fade-out');
        sceneContainer.innerHTML = '';
        
        // 恢复歌词容器
        lyricsContainer.classList.remove('hidden');
        
        // 重置索引，强制重新渲染
        currentSceneIndex = -1;
        currentLyricIndex = -1;
        
        // 立即更新场景和歌词
        updateScene();
        updateLyrics();
    }
});

// ==================== 初始化 ====================
preloadImages();
setTimeout(() => renderWaitingScreen(), 100);
</script>
